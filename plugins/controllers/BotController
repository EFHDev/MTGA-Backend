'use strict';

const database = require("../../engine/database")
const { getRandomFromArray, getRandomInt, debugOut, isDefined } = require("../utilities");
const fs = require('fs');

// Written by Nevermind of the Altered Escape team

const custDB = database.customization;
const globalsDB = database.core.globals;
const itemDB = database.items;
const localeDB = database.locales.en.locale;

const itemHandbook = arraySwap(localeDB.handbook);  // Make {itemCategoryString: templateID} lookup table
const templateParents = cacheTemplateParents();     // Make {itemID: templateID} lookup table

let aeNode = database.alteredEscape;

const writeDebugFile = false; // Write dbNode to Server/user/mods/Altered-Escape-2.2.0/src/dynamicBots/debug/dbNode.json

if (!isDefined(aeNode, 'settings.dynamicBots')) {
    throw new Error('AE dynamicBots Fatal Error: aeNode.settings.dynamicBots undefined');
}
const dbSettingsNode = aeNode.settings.dynamicBots;

if (!isDefined(aeNode, 'dynamicBots')) {
    aeNode.dynamicBots = {}; // Set up node where all cached data will be stored
}
let dbNode = aeNode.dynamicBots;

//bots_f = require(aeNode.constants.modDir + '/src/dynamicBots.js'); // Use our modified bots.js over JET bots.js

const writeDebugBots = false; // Write debug bot info at Server/user/mods/Altered-Escape-2.2.0/debug

exports.cache = () => { // Public function to be executed during TamperModLoad that caches data into useful objects to be used during bot generation
    const functionDebug = { name: 'dynamicBots.cache', debugMode: 0 }; // Debug settings for this function

    // Create caches
    cacheBotSettings();
    cacheBotNames();
    cacheBotDifficulty();
    cacheCustomization();
    cacheItemValues();
    cacheAmmoByCaliber();
    cacheQuestObjectives();
    cacheQuestHelperData();

    // Set up PMC, scav, and boss spawns on each map
    dbNode.botPreCache = {};
    botSpawns(); // Write bots into locations cache
    botPreCache(); // Calculates the number of bots that the client should pre-cache

    if (writeDebugFile) {
        fs.mkdirSync(aeNode.constants.modDir + '/debug', { recursive: true });
        fs.writeFileSync(aeNode.constants.modDir + '/debug/dbNode.json', JSON.stringify(dbNode, null, '\t'), 'utf8');
    }
}

function cacheTemplateParents() { // cacheTemplateParents creates a lookup table structured as: {itemID: templateID}
    let returnObj = {};

    for (const thisTemplateObj of global._database.templates.Items) {
        if (typeof thisTemplateObj.Id != 'undefined' && typeof thisTemplateObj.ParentId != 'undefined') {
            returnObj[thisTemplateObj.Id] = thisTemplateObj.ParentId;
        }
    }

    return returnObj;
}

function cacheBotSettings() { // cacheBotSettings reads botSettings files into the global cache
    const functionDebug = { name: 'dynamicBots.cacheBotSettings', debugMode: 0 }; // Debug settings for this function

    dbNode.botSettings = {}; // Define bot settings array
    const fileArray = fs.readdirSync(aeNode.constants.modDir + '/bots/profiles');
    for (const fileName of fileArray) {
        debugOut(functionDebug, `Caching botSettings: ${fileName}`, 2);
        let fileSplit = fileName.split('.'); // Get file name without extension
        dbNode.botSettings[fileSplit[0]] = require(aeNode.constants.modDir + '/bots/profiles/' + fileName, 2); // Cache bot settings file in global
    }
    prototypeBotSettings(); // Complete prototyped settings for bots so we don't have to use a hundred if statements
}

function cacheBotNames() { // cacheBotNames reads botNames files into the global cache
    const functionDebug = { name: 'dynamicBots.cacheBotNames', debugMode: 0 }; // Debug settings for this function

    dbNode.botNames = {}; // Define bot names array
    const fileArray = fs.readdirSync(aeNode.constants.modDir + '/bots/names');
    for (const fileName of fileArray) {
        let fileSplit = fileName.split('.');
        debugOut(functionDebug, `Caching botNames: ${fileName}`, 2);
        dbNode.botNames[fileSplit[0]] = fileIO.readParsed(aeNode.constants.modDir + '/bots/names/' + fileName); // Read file, parse to global
    }
}

function cacheBotDifficulty() { // cacheBotDifficulty reads botDifficulty files into the global cache
    const functionDebug = { name: 'dynamicBots.cacheBotDifficulty', debugMode: 0 }; // Debug settings for this function

    dbNode.botDifficulty = {}; // Define bot difficulty array
    const fileArray = fs.readdirSync(aeNode.constants.modDir + '/bots/difficulties');
    for (const fileName of fileArray) {
        let fileSplit = fileName.split('.');
        debugOut(functionDebug, `Caching botDifficulty: ${fileName}`, 2);
        dbNode.botDifficulty[fileSplit[0]] = require(aeNode.constants.modDir + '/bots/difficulties/' + fileName); // Read file, parse to global
    }
    prototypeBotDifficulty(dbNode);
}

function cacheCustomization() { // cacheCustomization reads customizations and formats them into arrays with just the info we need
    const functionDebug = { name: 'dynamicBots.cacheCustomization', debugMode: 0 }; // Debug settings for this function

    debugOut(functionDebug, `Caching bot customization options`, 2);
    dbNode.customization = {}; // Define customization array
    let voiceArray = [];
    const botSides = ['bear', 'savage', 'usec'];

    for (const thisSide of botSides) {
        dbNode.customization[thisSide] = {}; // Define array for this side

        dbNode.customization[thisSide].head = []; // Define arrays for all the parts
        dbNode.customization[thisSide].voice = [];
        dbNode.customization[thisSide].torso = {};
        dbNode.customization[thisSide].legs = {};
    }

    for (const thisItem in custDB) {
        let itemCategory;
        switch (custDB[thisItem]._parent) { // Set itemCategory based on what kind of item this is
            case '5cc085e214c02e000c6bea67':
                itemCategory = 'head';
                break;

            case '5fc100cf95572123ae738483':
                itemCategory = 'voice';
                break;

            case '5cd944ca1388ce03a44dc2a4':
                itemCategory = 'torso';
                break;

            case '5cd944d01388ce000a659df9':
                itemCategory = 'legs';
                break;
        }

        if (itemCategory) { // If a category was assigned then it's one of the items we want to record
            if (custDB[thisItem]._props.Side) {
                let itemSides = custDB[thisItem]._props.Side.map(side => side.toLowerCase()); // Get a list of all of the side this item belongs to (in lower case)

                for (const thisSide of botSides) {
                    if (itemSides.includes(thisSide)) { // If this side is included in item's Sides category
                        if (itemCategory == 'torso') {
                            dbNode.customization[thisSide][itemCategory][thisItem] = {};
                            dbNode.customization[thisSide][itemCategory][thisItem].body = custDB[thisItem]._props.Body;
                            dbNode.customization[thisSide][itemCategory][thisItem].hands = custDB[thisItem]._props.Hands;
                            debugOut(functionDebug, `Added ${thisSide} ${itemCategory} with body ${dbNode.customization[thisSide][itemCategory][thisItem].Body} and hands: ${dbNode.customization[thisSide][itemCategory][thisItem].Hands}`, 3);

                        } else if (itemCategory == 'legs') {
                            dbNode.customization[thisSide][itemCategory][thisItem] = custDB[thisItem]._props.Feet;
                            debugOut(functionDebug, `Added ${thisSide} ${itemCategory} ${thisItem} with feet ${dbNode.customization[thisSide][itemCategory][thisItem]}`, 3);

                        } else if (itemCategory == 'voice') {
                            dbNode.customization[thisSide][itemCategory].push(custDB[thisItem]._name);
                            voiceArray.push(custDB[thisItem]._name);
                            debugOut(functionDebug, `Added ${thisSide} ${itemCategory} ${custDB[thisItem]._name}`, 3);

                        } else {
                            dbNode.customization[thisSide][itemCategory].push(thisItem);
                            debugOut(functionDebug, `Added ${thisSide} ${itemCategory} ${thisItem}`, 3);
                        }
                    }
                }
            }
        }
    }

    for (const thisBotType in dbNode.botSettings) {
        const thisBotAppearanceNode = dbNode.botSettings[thisBotType].appearance;
        if (!thisBotAppearanceNode.useSide) { // If useSide is false, then we're using forced items
            for (const thisBodyPart of ['feet', 'hands', 'head', 'legs', 'torso', 'voice']) {
                if (isDefined(thisBotAppearanceNode, thisBodyPart)) {
                    for (const thisCustomizationID of thisBotAppearanceNode[thisBodyPart]) {
                        if (thisBodyPart == 'voice') {
                            if (thisCustomizationID != 'SectantPriest' && !voiceArray.includes(thisCustomizationID)) {
                                debugOut(functionDebug, `Bot ${thisBotType} contains invalid voice: ${thisCustomizationID}`, 0, 'error');
                            }
                        } else if (!isDefined(custDB, thisCustomizationID)) {
                            debugOut(functionDebug, `Bot ${thisBotType} contains invalid ${thisBodyPart}: ${thisCustomizationID}`, 0, 'error');
                        }
                    }
                }
            }
        }
    }
}

function cacheItemValues() { // cacheBotSettings reads botSettings files into the global cache
    const functionDebug = { name: 'dynamicBots.cacheItemValues', debugMode: 0 }; // Debug settings for this function

    debugOut(functionDebug, `Caching item values`, 2);

    if (!isDefined(dbNode, 'itemArray')) {
        dbNode.itemArray = {}; // Define item array
    }

    // Create a master array of all items and their values
    dbNode.itemArray.allItems = {};
    for (const thisItem in itemDB) {
        if (isDefined(itemDB, `${thisItem}._props.CreditsPrice`)) {
            dbNode.itemArray.allItems[thisItem] = itemDB[thisItem]._props.CreditsPrice;
        }
    }

    // Money
    dbNode.itemArray.money = {};
    if (isDefined(global._database, 'traders.58330581ace78e27b8b10cee.assort.barter_scheme.5eeca635bfed7142cb30f718')) {
        dbNode.itemArray.money['569668774bdc2da2298b4568'] = global._database.traders['58330581ace78e27b8b10cee'].assort.barter_scheme['5eeca635bfed7142cb30f718'][0][0].count; // Retrieve Euro value in roubles from Skier assort
    } else {
        dbNode.itemArray.money['569668774bdc2da2298b4568'] = 135
    }
    if (isDefined(global._database, 'traders.5935c25fb3acc3127c3d8cd9.assort.barter_scheme.5f004c011b27f811e5317c0b')) {
        dbNode.itemArray.money['5696686a4bdc2da3298b456a'] = global._database.traders['5935c25fb3acc3127c3d8cd9'].assort.barter_scheme['5f004c011b27f811e5317c0b'][0][0].count; // Retrieve USD value in roubles from Peacekeeper assort
    } else {
        dbNode.itemArray.money['5696686a4bdc2da3298b456a'] = 115
    }

    // Bot equipment
    dbNode.itemArray.headset = buildArrayFromCategory(itemHandbook, 'Headsets');
    dbNode.itemArray.helmet = buildArrayFromCategory(itemHandbook, 'Headwear & helmets');
    dbNode.itemArray.faceMask = buildArrayFromCategory(itemHandbook, 'Facecovers');
    dbNode.itemArray.armBand = buildArrayFromParent('Armbands', '5b3f15d486f77432d0509248'); // Uses 'Gear Components' category which is shared by stuff like helmet face shields >:(
    dbNode.itemArray.chestArmor = buildArrayFromCategory(itemHandbook, 'Armor vests');
    dbNode.itemArray.eyeWear = buildArrayFromCategory(itemHandbook, 'Visors');
    dbNode.itemArray.chestRig = buildArrayFromCategory(itemHandbook, 'Tactical rigs');
    dbNode.itemArray.backPack = buildArrayFromCategory(itemHandbook, 'Backpacks');
    dbNode.itemArray.melee = buildArrayFromCategory(itemHandbook, 'Melee weapons');

    // Face masks that clip through hats:
    const defaultFacemaskClipsWithHelmet = [
        '572b7f1624597762ae139822', // Balaclava
        '5ab8f39486f7745cd93a1cca', // Cold Fear Infrared balaclava
        '5ab8f4ff86f77431c60d91ba', // Ghost balaclava
        '5ab8f85d86f7745cd93a1cf5', // Shemagh
        '5b4325355acfc40019478126', // Shemagh (var. 2)
        '5b4326435acfc433000ed01d', // Neoprene mask
        '5b432c305acfc40019478128', // GP-5 gasmask
        '5b432f3d5acfc4704b4a1dfb', // Momex balaclava
        '5bd06f5d86f77427101ad47c', // Slender mask
        '5bd0716d86f774171822ef4b', // Misha Mayorov's mask
        '5e54f79686f7744022011103', // Pestily plague mask
        '5fd8d28367cb5e077335170f'  // Smoke balaclava
    ];

    if (isDefined(dbNode.itemArray, 'facemaskClipsWithHelmet')) { // itemLoader already created this array
        dbNode.itemArray.facemaskClipsWithHelmet.push(...defaultFacemaskClipsWithHelmet);
    } else {
        dbNode.itemArray.facemaskClipsWithHelmet = defaultFacemaskClipsWithHelmet; // Set to only default items
    }

    // Optics and mounts
    dbNode.itemArray.mounts = buildArrayFromCategory(itemHandbook, 'Mounts');
    dbNode.itemArray.reflex = {
        ...buildArrayFromCategory(itemHandbook, 'Assault scopes'),
        ...buildArrayFromCategory(itemHandbook, 'Collimators'),
        ...buildArrayFromCategory(itemHandbook, 'Compact collimators'),
    };
    dbNode.itemArray.optics = buildArrayFromCategory(itemHandbook, 'Optics');

    // Mags and ammo
    dbNode.itemArray.magazines = buildArrayFromCategory(itemHandbook, 'Magazines');
    dbNode.itemArray.ammo = buildArrayFromCategory(itemHandbook, 'Rounds');
    dbNode.itemArray.ammoBoxes = buildArrayFromCategory(itemHandbook, 'Ammo boxes');

    // Grenades
    dbNode.itemArray.grenades = buildArrayFromCategory(itemHandbook, 'Throwables');

    // Healing items
    dbNode.itemArray.injuryTreatment = buildArrayFromCategory(itemHandbook, 'Injury treatment');
    dbNode.itemArray.medkits = buildArrayFromCategory(itemHandbook, 'Medkits');
    dbNode.itemArray.painkillers = buildArrayFromCategory(itemHandbook, 'Pills');
    dbNode.itemArray.stims = buildArrayFromCategory(itemHandbook, 'Injectors');

    // Food and drink
    dbNode.itemArray.drink = buildArrayFromCategory(itemHandbook, 'Drinks');
    dbNode.itemArray.food = buildArrayFromCategory(itemHandbook, 'Food');

    // Random loot
    dbNode.itemArray.randomLoot = {
        ...buildArrayFromCategory(itemHandbook, 'Energy elements', 'rarity'),
        ...buildArrayFromCategory(itemHandbook, 'Building materials', 'rarity'),
        ...buildArrayFromCategory(itemHandbook, 'Electronics', 'rarity'),
        ...buildArrayFromCategory(itemHandbook, 'Household materials', 'rarity'),
        ...buildArrayFromCategory(itemHandbook, 'Valuables', 'rarity'),
        ...buildArrayFromCategory(itemHandbook, 'Flammable materials', 'rarity'),
        ...buildArrayFromCategory(itemHandbook, 'Medical supplies', 'rarity'),
        ...buildArrayFromCategory(itemHandbook, 'Others', 'rarity'),
        ...buildArrayFromCategory(itemHandbook, 'Tools', 'rarity'),
        ...buildArrayFromCategory(itemHandbook, 'Info items', 'rarity'),

        ...buildArrayFromCategory(itemHandbook, 'Gear components', 'rarity'),
        ...buildArrayFromCategory(itemHandbook, 'Bipods', 'rarity'),
        ...buildArrayFromCategory(itemHandbook, 'Fore grips', 'rarity'),
        ...buildArrayFromCategory(itemHandbook, 'Muzzle devices', 'rarity'),
        ...buildArrayFromCategory(itemHandbook, 'Flashhiders & brakes', 'rarity'),
        ...buildArrayFromCategory(itemHandbook, 'Muzzle adapters', 'rarity'),
        ...buildArrayFromCategory(itemHandbook, 'Suppressors', 'rarity'),
        ...buildArrayFromCategory(itemHandbook, 'Light & laser devices', 'rarity'),
        ...buildArrayFromCategory(itemHandbook, 'Tactical combo devices', 'rarity'),
        ...buildArrayFromCategory(itemHandbook, 'Flashlights', 'rarity'),
        ...buildArrayFromCategory(itemHandbook, 'Laser target pointers', 'rarity'),
        ...buildArrayFromCategory(itemHandbook, 'Assault scopes', 'rarity'),
        ...buildArrayFromCategory(itemHandbook, 'Collimators', 'rarity'),
        ...buildArrayFromCategory(itemHandbook, 'Compact collimators', 'rarity'),
        ...buildArrayFromCategory(itemHandbook, 'Optics', 'rarity'),
        ...buildArrayFromCategory(itemHandbook, 'Charging handles', 'rarity'),
        ...buildArrayFromCategory(itemHandbook, 'Mounts', 'rarity'),
        ...buildArrayFromCategory(itemHandbook, 'Stocks & chassis', 'rarity'),
        ...buildArrayFromCategory(itemHandbook, 'Barrels', 'rarity'),
        ...buildArrayFromCategory(itemHandbook, 'Handguards', 'rarity'),
        ...buildArrayFromCategory(itemHandbook, 'Gas blocks', 'rarity'),
        ...buildArrayFromCategory(itemHandbook, 'Pistol grips', 'rarity'),
        ...buildArrayFromCategory(itemHandbook, 'Receivers & slides', 'rarity'),
        ...buildArrayFromCategory(itemHandbook, 'Magazines', 'rarity'),

        ...buildArrayFromCategory(itemHandbook, 'Assault carbines', 'rarity'),
        ...buildArrayFromCategory(itemHandbook, 'Assault rifles', 'rarity'),
        ...buildArrayFromCategory(itemHandbook, 'Bolt-action rifles', 'rarity'),
        ...buildArrayFromCategory(itemHandbook, 'Machine guns', 'rarity'),
        ...buildArrayFromCategory(itemHandbook, 'Marksman rifles', 'rarity'),
        ...buildArrayFromCategory(itemHandbook, 'Pistols', 'rarity'),
        ...buildArrayFromCategory(itemHandbook, 'Shotguns', 'rarity'),
        ...buildArrayFromCategory(itemHandbook, 'SMGs', 'rarity'),

        ...buildArrayFromCategory(itemHandbook, 'Rounds', 'rarity'),
        ...buildArrayFromCategory(itemHandbook, 'Ammo boxes', 'rarity'),

        ...buildArrayFromCategory(itemHandbook, 'Mechanical keys', 'rarity'),
        ...buildArrayFromCategory(itemHandbook, 'Electronic keys', 'rarity')
    }

    // Create loot pools
    dbNode.itemArray.lootPool = {
        common: [],
        rare: [],
        superRare: []
    };

    for (const thisLoot in dbNode.itemArray.randomLoot) {
        if (dbNode.itemArray.randomLoot[thisLoot] == 'Common') {
            dbNode.itemArray.lootPool.common.push(thisLoot);
        } else if (dbNode.itemArray.randomLoot[thisLoot] == 'Rare') {
            dbNode.itemArray.lootPool.rare.push(thisLoot);
        } else if (dbNode.itemArray.randomLoot[thisLoot] == 'Superrare') {
            dbNode.itemArray.lootPool.superRare.push(thisLoot);
        }
    }

    debugOut(functionDebug, `Loot pools -> common: ${dbNode.itemArray.lootPool.common.length}, rare: ${dbNode.itemArray.lootPool.rare.length}, superRare: ${dbNode.itemArray.lootPool.superRare.length}`, 2);

    // Define weapon arrays
    dbNode.itemArray.assaultCarbine = {};
    dbNode.itemArray.assaultRifle = {};
    dbNode.itemArray.boltAction = {};
    dbNode.itemArray.grenadeLauncher = {};
    dbNode.itemArray.machineGun = {};
    dbNode.itemArray.marksmanRifle = {};
    dbNode.itemArray.pistol = {};
    dbNode.itemArray.submachinegun = {};
    dbNode.itemArray.shotgun = {};

    // Define template match array
    const templateMatch = {
        '5b5f78e986f77447ed5636b1': 'assaultCarbine',
        '5b5f78fc86f77409407a7f90': 'assaultRifle',
        '5b5f798886f77447ed5636b5': 'boltAction',
        '5b5f79d186f774093f2ed3c2': 'grenadeLauncher',
        '5b5f79a486f77409407a7f94': 'machineGun',
        '5b5f791486f774093f2ed3be': 'marksmanRifle',
        '5b5f792486f77447ed5636b3': 'pistol',
        '5b5f796a86f774093f2ed3c0': 'submachinegun',
        '5b5f794b86f77409407a7f92': 'shotgun'
    };

    // Add the value of all parts for each weapon preset so we have a baseline of how much each weapon is worth
    const weaponPresets = globalsDB.ItemPresets;
    presetLoop:
    for (const thisPreset in weaponPresets) {
        let presetValue = 0;
        let presetItems = weaponPresets[thisPreset]._items;
        let lowerReceiver;

        for (const thisItem of presetItems) {
            if (isDefined(itemDB, thisItem._tpl)) {
                presetValue += itemDB[thisItem._tpl]._props.CreditsPrice; // Add the value of each part to the total
                if (!isDefined(thisItem, 'parentId')) {
                    lowerReceiver = thisItem._tpl; // Lower won't have a parent
                    if (isDefined(itemDB, `${lowerReceiver}._props.Rarity`) && itemDB[lowerReceiver]._props.Rarity == 'Not_exist') { // Don't add items that shouldn't spawn
                        continue presetLoop;
                    }
                }
            } else {
                debugOut(functionDebug, `${thisPreset} preset contains invalid item: ${thisItem._tpl}`, 0, 'error');
                continue presetLoop;
            }
        }
        debugOut(functionDebug, `${thisPreset} preset value: ${presetValue}, lowerID: ${lowerReceiver}`, 2);

        const lowerParent = templateParents[lowerReceiver];

        if (isDefined(templateMatch, lowerParent)) {
            const weaponType = templateMatch[lowerParent];

            dbNode.itemArray[weaponType][thisPreset] = presetValue; // Add the preset to the specified weapon type with rouble value
        } else {
            debugOut(functionDebug, `Preset ${thisPreset} with base item: ${lowerReceiver} does not match one of the known weapon types`, 2, 'warning');
        }
    }
}

function cacheAmmoByCaliber() { // cacheAmmoByCaliber creates arrays of ammos by caliber
    const functionDebug = { name: 'dynamicBots.cacheAmmoByCaliber', debugMode: 0 }; // Debug settings for this function

    dbNode.ammoCaliber = {}
    for (const thisAmmo in dbNode.itemArray.ammo) {
        if (isDefined(itemDB[thisAmmo]._props, 'Caliber')) {
            const thisAmmoCaliber = itemDB[thisAmmo]._props.Caliber;

            if (typeof dbNode.ammoCaliber[thisAmmoCaliber] == 'undefined') { // Can't use isDefined because key names (ammo calibers) are likely to contain periods
                debugOut(functionDebug, `New caliber: ${thisAmmoCaliber}: [${thisAmmo}]`, 2);
                dbNode.ammoCaliber[thisAmmoCaliber] = [thisAmmo];
            } else {
                debugOut(functionDebug, `Pushing to caliber: ${thisAmmoCaliber}: -> ${thisAmmo}`, 2);
                dbNode.ammoCaliber[thisAmmoCaliber].push(thisAmmo);
            }
        } else {
            debugOut(functionDebug, `Ammo caliber undefined: ${thisAmmo}`, 0, 'error');
        }
    }

    //console.info(dbNode.ammoCaliber);
}

function cacheQuestObjectives() { // cacheQuestObjectives caches HandoverItem objectives of quests (except marked quest items)
    const functionDebug = { name: 'dynamicBots.cacheQuestObjectives', debugMode: 0 }; // Debug settings for this function
    const questDB = global._database.quests;
    dbNode.questObjectives = {}; // Define questObjectives array

    for (const thisQuestObj of questDB) {
        if (isDefined(thisQuestObj, '_id')) {
            const thisQuestID = thisQuestObj._id;
            if (isDefined(thisQuestObj, 'conditions.AvailableForFinish')) {
                conditionsLoop:
                for (const thisConditionObj of thisQuestObj.conditions.AvailableForFinish) {
                    if (isDefined(thisConditionObj, '_parent') && thisConditionObj._parent == 'HandoverItem' && isDefined(thisConditionObj, '_props.id') && isDefined(thisConditionObj._props, 'target') && isDefined(thisConditionObj._props, 'value')) {
                        for (const thisTarget of thisConditionObj._props.target) {
                            if (!isDefined(itemDB, thisTarget) || (isDefined(itemDB[thisTarget], '_props.QuestItem') && itemDB[thisTarget]._props.QuestItem)) {
                                continue conditionsLoop;
                            }
                        }

                        if (!isDefined(dbNode.questObjectives, thisQuestID)) {
                            dbNode.questObjectives[thisQuestID] = {};
                        }

                        const thisConditionID = thisConditionObj._props.id;

                        dbNode.questObjectives[thisQuestID][thisConditionID] = {
                            quantity: Number(thisConditionObj._props.value),
                            items: thisConditionObj._props.target
                        };
                    }
                }
            }
        } else {
            debugOut(functionDebug, 'Quest _id undefined', 0, 'error');
        }
    }
}

function cacheQuestHelperData() { // cacheQuestHelperData loads questHelper data for this server from file
    const filePath = aeNode.constants.modDir + '/data/questHelper.json';
    if (fs.existsSync(filePath)) {
        dbNode.questHelper = fileIO.readParsed(filePath); // Read from file if it exists
    } else {
        dbNode.questHelper = {}; // Create empty node
    }
}

function buildArrayFromCategory(itemHandbook, itemCategory, value = 'price') { // buildArrayFromCategory takes a handbook category and builds an array with the item's price or rarity
    const functionDebug = { name: 'dynamicBots.buildArrayFromCategory', debugMode: 0 }; // Debug settings for this function

    debugOut(functionDebug, `Building array: ${itemCategory}`, 2);
    const templateID = itemHandbook[itemCategory]; // Look item category up in the handbook and find the corresponding ID

    let itemArray = {};
    if (value == 'rarity') {
        for (const thisItem in templateParents) {
            if (templateParents[thisItem] == templateID) {
                if (isDefined(itemDB, `${thisItem}._props.Rarity`)) {
                    if (itemDB[thisItem]._props.Rarity != 'Not_exist') {
                        itemArray[thisItem] = itemDB[thisItem]._props.Rarity; // Push this item to the array, using its ID as key and rarity as value
                    }
                } else {
                    debugOut(functionDebug, `${thisItem} missing property: ._props.Rarity`, 0, 'error');
                }
            }
        }
    } else {
        for (const thisItem in templateParents) {
            if (templateParents[thisItem] == templateID) {
                let thisItemRarity = 'Not_exist';
                if (isDefined(itemDB, `${thisItem}._props.Rarity`)) {
                    thisItemRarity = itemDB[thisItem]._props.Rarity;
                }
                if (thisItemRarity != 'Not_exist') {
                    itemArray[thisItem] = dbNode.itemArray.allItems[thisItem]; // Push this item to the array, using its ID as key and price as value
                }
            }
        }
    }
    debugOut(functionDebug, `${Object.keys(itemArray).length} ${itemCategory} added`, 2);

    return itemArray;
}

function buildArrayFromParent(itemCategory, itemParentID) { // buildArrayFromParent takes an item parent ID and builds an array with the item's price
    const functionDebug = { name: 'dynamicBots.buildArrayFromParent', debugMode: 0 }; // Debug settings for this function

    debugOut(functionDebug, `Building array: ${itemCategory} from parent ${itemParentID}`, 2);

    let itemArray = {};
    for (const thisItem in itemDB) {
        if (itemDB[thisItem]._parent == itemParentID) {
            itemArray[thisItem] = dbNode.itemArray.allItems[thisItem]; // Push this item to the array, using its ID as key and price as value
        }
    }
    debugOut(functionDebug, `${Object.keys(itemArray).length} ${itemCategory} added`, 2);

    return itemArray;
}

function arraySwap(inputArray) { // arraySwap is a function that swaps the keys and values of a shallow associative array
    let returnArray = {};

    Object.keys(inputArray).forEach(thisKey => {
        returnArray[inputArray[thisKey]] = thisKey; // Assign each value to its key
    });

    return returnArray;
}

function prototypeBotSettings() { // prototypeBotSettings takes partial info in botSettings arrays and fills out all missing fields with data from the 1-10 level
    const functionDebug = { name: 'dynamicBots.prototypeBotSettings', debugMode: 0 }; // Debug settings for this function

    // Check that everything is defined
    const defineArray = [
        'appearance.botSide',
        'appearance.useSide',
        'appearance.head',
        'appearance.voice',
        'appearance.torso',
        'appearance.legs',
        'experience.level_Min',
        'experience.level_Max',
        'experience.XPreward_Min',
        'experience.XPreward_Max',
        'health.hydration_Min',
        'health.hydration_Max',
        'health.energy_Min',
        'health.energy_Max',
        'health.temperature_Min',
        'health.temperature_Max',
        'health.healthHead_Min',
        'health.healthHead_Max',
        'health.healthChest_Min',
        'health.healthChest_Max',
        'health.healthStomach_Min',
        'health.healthStomach_Max',
        'health.healthArms_Min',
        'health.healthArms_Max',
        'health.healthLegs_Min',
        'health.healthLegs_Max',
        'names.nameSet',
        'names.chanceForNickname',
        'names.addNumbersAfterNickname',
        'level_1_10.skills',
        'level_1_10.headset.chanceToEquip',
        'level_1_10.headset.value_Min',
        'level_1_10.headset.value_Max',
        'level_1_10.headset.forceItems',
        'level_1_10.headset.forbidItems',
        'level_1_10.helmet.chanceToEquip',
        'level_1_10.helmet.chanceForArmored',
        'level_1_10.helmet.value_Min',
        'level_1_10.helmet.value_Max',
        'level_1_10.helmet.armorClass_Min',
        'level_1_10.helmet.armorClass_Max',
        'level_1_10.helmet.chanceForMods',
        'level_1_10.helmet.modMaxTries',
        'level_1_10.helmet.modBudget_Min',
        'level_1_10.helmet.modBudget_Max',
        'level_1_10.helmet.durability_Min',
        'level_1_10.helmet.durability_Max',
        'level_1_10.helmet.forceItemBuild',
        'level_1_10.helmet.forceItems',
        'level_1_10.helmet.forbidItems',
        'level_1_10.faceMask.chanceToEquip',
        'level_1_10.faceMask.chanceForArmored',
        'level_1_10.faceMask.value_Min',
        'level_1_10.faceMask.value_Max',
        'level_1_10.faceMask.armorClass_Min',
        'level_1_10.faceMask.armorClass_Max',
        'level_1_10.faceMask.durability_Min',
        'level_1_10.faceMask.durability_Max',
        'level_1_10.faceMask.forceItems',
        'level_1_10.faceMask.forbidItems',
        'level_1_10.armBand.chanceToEquip',
        'level_1_10.armBand.value_Min',
        'level_1_10.armBand.value_Max',
        'level_1_10.armBand.forceItems',
        'level_1_10.armBand.forbidItems',
        'level_1_10.chestArmor.chanceToEquip',
        'level_1_10.chestArmor.value_Min',
        'level_1_10.chestArmor.value_Max',
        'level_1_10.chestArmor.armorClass_Min',
        'level_1_10.chestArmor.armorClass_Max',
        'level_1_10.chestArmor.durability_Min',
        'level_1_10.chestArmor.durability_Max',
        'level_1_10.chestArmor.forceItems',
        'level_1_10.chestArmor.forbidItems',
        'level_1_10.eyeWear.chanceToEquip',
        'level_1_10.eyeWear.chanceForArmored',
        'level_1_10.eyeWear.value_Min',
        'level_1_10.eyeWear.value_Max',
        'level_1_10.eyeWear.armorClass_Min',
        'level_1_10.eyeWear.armorClass_Max',
        'level_1_10.eyeWear.durability_Min',
        'level_1_10.eyeWear.durability_Max',
        'level_1_10.eyeWear.forceItems',
        'level_1_10.eyeWear.forbidItems',
        'level_1_10.chestRig.chanceToEquip',
        'level_1_10.chestRig.chanceForArmored',
        'level_1_10.chestRig.value_Min',
        'level_1_10.chestRig.value_Max',
        'level_1_10.chestRig.armorClass_Min',
        'level_1_10.chestRig.armorClass_Max',
        'level_1_10.chestRig.durability_Min',
        'level_1_10.chestRig.durability_Max',
        'level_1_10.chestRig.forceItems',
        'level_1_10.chestRig.forbidItems',
        'level_1_10.backPack.chanceToEquip',
        'level_1_10.backPack.value_Min',
        'level_1_10.backPack.value_Max',
        'level_1_10.backPack.forceChestRig',
        'level_1_10.backPack.forceItems',
        'level_1_10.backPack.forbidItems',
        'level_1_10.melee.chanceToEquip',
        'level_1_10.melee.value_Min',
        'level_1_10.melee.value_Max',
        'level_1_10.melee.durability_Min',
        'level_1_10.melee.durability_Max',
        'level_1_10.melee.forceItems',
        'level_1_10.melee.forbidItems',
        'level_1_10.weapons.chanceForPrimary',
        'level_1_10.weapons.chanceForSecondary',
        'level_1_10.weapons.chanceForPistol',
        'level_1_10.weapons.primary.value_Min',
        'level_1_10.weapons.primary.value_Max',
        'level_1_10.weapons.primary.preference.assaultCarbine',
        'level_1_10.weapons.primary.preference.assaultRifle',
        'level_1_10.weapons.primary.preference.boltAction',
        'level_1_10.weapons.primary.preference.grenadeLauncher',
        'level_1_10.weapons.primary.preference.machineGun',
        'level_1_10.weapons.primary.preference.marksmanRifle',
        'level_1_10.weapons.primary.preference.submachinegun',
        'level_1_10.weapons.primary.preference.shotgun',
        'level_1_10.weapons.primary.bullet_ValueMin',
        'level_1_10.weapons.primary.bullet_ValueMax',
        'level_1_10.weapons.primary.bulletDmg_Max',
        'level_1_10.weapons.primary.bulletPen_Max',
        'level_1_10.weapons.primary.extraMags_Min',
        'level_1_10.weapons.primary.extraMags_Max',
        'level_1_10.weapons.primary.matchMags',
        'level_1_10.weapons.primary.chanceForAMissingPart',
        'level_1_10.weapons.primary.chanceForMods',
        'level_1_10.weapons.primary.modMaxTries',
        'level_1_10.weapons.primary.modBudget_Min',
        'level_1_10.weapons.primary.modBudget_Max',
        'level_1_10.weapons.primary.chanceForOptic',
        'level_1_10.weapons.primary.longRangeOptic',
        'level_1_10.weapons.primary.opticBudget_Min',
        'level_1_10.weapons.primary.opticBudget_Max',
        'level_1_10.weapons.primary.durability_Min',
        'level_1_10.weapons.primary.durability_Max',
        'level_1_10.weapons.primary.forceItemBuild',
        'level_1_10.weapons.primary.forcePresets',
        'level_1_10.weapons.primary.forbidItems',
        'level_1_10.weapons.pistol.value_Min',
        'level_1_10.weapons.pistol.value_Max',
        'level_1_10.weapons.pistol.bullet_ValueMin',
        'level_1_10.weapons.pistol.bullet_ValueMax',
        'level_1_10.weapons.pistol.bulletDmg_Max',
        'level_1_10.weapons.pistol.bulletPen_Max',
        'level_1_10.weapons.pistol.extraMags_Min',
        'level_1_10.weapons.pistol.extraMags_Max',
        'level_1_10.weapons.pistol.matchMags',
        'level_1_10.weapons.pistol.chanceForAMissingPart',
        'level_1_10.weapons.pistol.chanceForMods',
        'level_1_10.weapons.pistol.modMaxTries',
        'level_1_10.weapons.pistol.modBudget_Min',
        'level_1_10.weapons.pistol.modBudget_Max',
        'level_1_10.weapons.pistol.chanceForOptic',
        'level_1_10.weapons.pistol.opticBudget_Min',
        'level_1_10.weapons.pistol.opticBudget_Max',
        'level_1_10.weapons.pistol.durability_Min',
        'level_1_10.weapons.pistol.durability_Max',
        'level_1_10.weapons.pistol.forceItemBuild',
        'level_1_10.weapons.pistol.forcePresets',
        'level_1_10.weapons.pistol.forbidItems',
        'level_1_10.inventory.pockets',
        'level_1_10.inventory.consumables.drink_Chance',
        'level_1_10.inventory.consumables.drink_Min',
        'level_1_10.inventory.consumables.drink_Max',
        'level_1_10.inventory.consumables.drink_ValueMax',
        'level_1_10.inventory.consumables.food_Chance',
        'level_1_10.inventory.consumables.food_Min',
        'level_1_10.inventory.consumables.food_Max',
        'level_1_10.inventory.consumables.food_ValueMax',
        'level_1_10.inventory.grenades.grenades_Chance',
        'level_1_10.inventory.grenades.grenades_Min',
        'level_1_10.inventory.grenades.grenades_Max',
        'level_1_10.inventory.grenades.matchGrenades',
        'level_1_10.inventory.grenades.forceItems',
        'level_1_10.inventory.grenades.forbidItems',
        'level_1_10.inventory.healing.injuryTreatment_Min',
        'level_1_10.inventory.healing.injuryTreatment_Max',
        'level_1_10.inventory.healing.injuryTreatment_ValueMax',
        'level_1_10.inventory.healing.medkits_Min',
        'level_1_10.inventory.healing.medkits_Max',
        'level_1_10.inventory.healing.medkits_ValueMax',
        'level_1_10.inventory.healing.painkillers_Min',
        'level_1_10.inventory.healing.painkillers_Max',
        'level_1_10.inventory.healing.painkillers_ValueMax',
        'level_1_10.inventory.healing.stims_Min',
        'level_1_10.inventory.healing.stims_Max',
        'level_1_10.inventory.healing.stims_ValueMax',
        'level_1_10.inventory.healing.forceItems',
        'level_1_10.inventory.healing.forbidItems',
        'level_1_10.inventory.randomLoot.money_Type',
        'level_1_10.inventory.randomLoot.money_Chance',
        'level_1_10.inventory.randomLoot.money_Min',
        'level_1_10.inventory.randomLoot.money_Max',
        'level_1_10.inventory.randomLoot.items_Min',
        'level_1_10.inventory.randomLoot.items_Max',
        'level_1_10.inventory.randomLoot.chanceForRare',
        'level_1_10.inventory.randomLoot.chanceForSuperRare',
        'level_1_10.inventory.randomLoot.forceItems',
        'level_1_10.inventory.randomLoot.forbidItems',
        'level_1_10.inventory.specificLoot'
    ]

    for (const thisBotType in dbNode.botSettings) {
        debugOut(functionDebug, `Completing prototype for bot type: ${thisBotType}`, 2);

        let defineError = false;
        for (const thisKey of defineArray) {
            if (!isDefined(dbNode.botSettings[thisBotType], thisKey)) {
                debugOut(functionDebug, `botSettings.${thisBotType}.${thisKey} is not defined`, 0, 'error');
                defineError = true;
            }
        }

        if (!defineError) {
            let levelArray = [];
            for (const thisKey in dbNode.botSettings[thisBotType]) {
                if (thisKey.startsWith('level')) {
                    levelArray.push(thisKey); // Add all keys that start with 'level'
                }
            }

            let levelPrototype = levelArray.shift(); // Extract first level as the prototype
            debugOut(functionDebug, `levelPrototype: ${levelPrototype}`, 3);
            let prototypeObj = dbNode.botSettings[thisBotType][levelPrototype]; // This is the prototype object which all subesequent objects will reference

            for (const thisLevel of levelArray) {
                debugOut(functionDebug, `thisLevel: ${thisLevel}`, 3);
                let thisLevelObj = dbNode.botSettings[thisBotType][thisLevel];

                for (const thisKey in prototypeObj) {
                    debugOut(functionDebug, `thisKey: ${thisKey}`, 3);
                    prototypeCopy(prototypeObj, thisLevelObj, thisKey); // Copy all objects with prototyping
                }
            }
        }
    }
}

function prototypeBotDifficulty() { // prototypeBotDifficulty takes partial info in botDifficulty arrays and fills out all the missing fields with data from the _default botDifficulty file
    const functionDebug = { name: 'dynamicBots.prototypeBotDifficulty', debugMode: 0 }; // Debug settings for this function

    if (isDefined(dbNode, 'botDifficulty._default')) {
        let defaultNode = dbNode.botDifficulty._default;
        // Check that everything is defined
        let defineArray = [
            'Lay',
            'Aiming',
            'Look',
            'Shoot',
            'Move',
            'Grenade',
            'Change',
            'Cover',
            'Patrol',
            'Hearing',
            'Mind',
            'Boss',
            'Core',
            'Scattering'
        ]

        let defineError = false;
        for (const thisKey of defineArray) {
            if (!isDefined(defaultNode, thisKey)) {
                debugOut(functionDebug, `Default node key undefined: dbNode.botDifficulty._default.${thisKey}`, 0, 'error');
                defineError = true;
            }
        }

        if (defineError) {
            throw 'AE dynamicBots Fatal Error: botDifficulty/_default.js missing keys';
        } else {
            // Static calculations
            defaultNode.Lay.DIST_ENEMY_GETUP_LAY_SQRT = squareAndRound(defaultNode.Lay.DIST_ENEMY_GETUP_LAY); // Square
            defaultNode.Lay.DIST_ENEMY_NULL_DANGER_LAY_SQRT = squareAndRound(defaultNode.Lay.DIST_ENEMY_NULL_DANGER_LAY);
            defaultNode.Lay.DIST_TO_COVER_TO_LAY_SQRT = squareAndRound(defaultNode.Lay.DIST_TO_COVER_TO_LAY);
            defaultNode.Lay.MIN_CAN_LAY_DIST_SQRT = squareAndRound(defaultNode.Lay.MIN_CAN_LAY_DIST);
            defaultNode.Lay.MAX_CAN_LAY_DIST_SQRT = squareAndRound(defaultNode.Lay.MAX_CAN_LAY_DIST);
            defaultNode.Lay.DIST_ENEMY_CAN_LAY_SQRT = squareAndRound(defaultNode.Lay.DIST_ENEMY_CAN_LAY);

            defaultNode.Aiming.RECALC_SQR_DIST = squareAndRound(defaultNode.Aiming.RECALC_DIST);

            defaultNode.Look.DIST_SQRT_REPEATED_SEEN = squareAndRound(defaultNode.Look.DIST_REPEATED_SEEN);
            defaultNode.Look.MAX_VISION_GRASS_METERS_OPT = inverseAndRound(defaultNode.Look.MAX_VISION_GRASS_METERS); // Inverse
            defaultNode.Look.MAX_VISION_GRASS_METERS_FLARE_OPT = inverseAndRound(defaultNode.Look.MAX_VISION_GRASS_METERS_FLARE);

            defaultNode.Shoot.FAR_DIST_ENEMY_SQR = squareAndRound(defaultNode.Shoot.FAR_DIST_ENEMY);
            defaultNode.Shoot.RUN_DIST_NO_AMMO_SQRT = squareAndRound(defaultNode.Shoot.RUN_DIST_NO_AMMO);

            defaultNode.Move.DIST_TO_CAN_CHANGE_WAY_SQR = squareAndRound(defaultNode.Move.DIST_TO_CAN_CHANGE_WAY);
            defaultNode.Move.DIST_TO_START_RAYCAST_SQR = squareAndRound(defaultNode.Move.DIST_TO_START_RAYCAST);
            defaultNode.Move.BASE_SQRT_START_SERACH = squareAndRound(defaultNode.Move.BASE_START_SERACH);
            defaultNode.Move.FAR_DIST_SQR = squareAndRound(defaultNode.Move.FAR_DIST);

            defaultNode.Grenade.CLOSE_TO_SMOKE_TO_SHOOT_SQRT = squareAndRound(defaultNode.Grenade.CLOSE_TO_SMOKE_TO_SHOOT);
            defaultNode.Grenade.MAX_FLASHED_DIST_TO_SHOOT_SQRT = squareAndRound(defaultNode.Grenade.MAX_FLASHED_DIST_TO_SHOOT);
            defaultNode.Grenade.REQUEST_DIST_MUST_THROW_SQRT = squareAndRound(defaultNode.Grenade.REQUEST_DIST_MUST_THROW);
            defaultNode.Grenade.RUN_AWAY_SQR = squareAndRound(defaultNode.Grenade.RUN_AWAY);
            defaultNode.Grenade.ADD_GRENADE_AS_DANGER_SQR = squareAndRound(defaultNode.Grenade.ADD_GRENADE_AS_DANGER);
            defaultNode.Grenade.MIN_DIST_NOT_TO_THROW_SQR = squareAndRound(defaultNode.Grenade.MIN_DIST_NOT_TO_THROW);
            defaultNode.Grenade.MIN_THROW_GRENADE_DIST_SQRT = squareAndRound(defaultNode.Grenade.MIN_THROW_GRENADE_DIST);

            defaultNode.Cover.SDIST_MAX_REWORK_NOT_TO_SHOOT = squareAndRound(defaultNode.Cover.DIST_MAX_REWORK_NOT_TO_SHOOT);
            defaultNode.Cover.MIN_TO_ENEMY_TO_BE_NOT_SAFE_SQRT = squareAndRound(defaultNode.Cover.MIN_TO_ENEMY_TO_BE_NOT_SAFE);
            defaultNode.Cover.STAY_IF_FAR_SQRT = squareAndRound(defaultNode.Cover.STAY_IF_FAR);
            defaultNode.Cover.RUN_IF_FAR_SQRT = squareAndRound(defaultNode.Cover.RUN_IF_FAR);
            defaultNode.Cover.DIST_CANT_CHANGE_WAY_SQR = squareAndRound(defaultNode.Cover.DIST_CANT_CHANGE_WAY);
            defaultNode.Cover.MAX_DIST_OF_COVER_SQR = squareAndRound(defaultNode.Cover.MAX_DIST_OF_COVER);

            defaultNode.Patrol.MIN_DIST_TO_CLOSE_TALK_SQR = squareAndRound(defaultNode.Patrol.MIN_DIST_TO_CLOSE_TALK);

            defaultNode.Mind.MAX_AGGRO_BOT_DIST_SQR = squareAndRound(defaultNode.Mind.MAX_AGGRO_BOT_DIST);

            defaultNode.Boss.KOJANIY_DIST_CORE_SPOS_RECALC_SQRT = squareAndRound(defaultNode.Boss.KOJANIY_DIST_CORE_SPOS_RECALC);
            defaultNode.Boss.BOSS_DIST_TO_WARNING_OUT_SQRT = squareAndRound(defaultNode.Boss.BOSS_DIST_TO_WARNING_OUT);
            defaultNode.Boss.BOSS_DIST_TO_SHOOT_SQRT = squareAndRound(defaultNode.Boss.BOSS_DIST_TO_SHOOT);
            defaultNode.Boss.BOSS_DIST_TO_WARNING_SQRT = squareAndRound(defaultNode.Boss.BOSS_DIST_TO_WARNING);
            defaultNode.Boss.MAX_DIST_DECIDER_TO_SEND_SQRT = squareAndRound(defaultNode.Boss.MAX_DIST_DECIDER_TO_SEND);
            defaultNode.Boss.MAX_DIST_COVER_BOSS_SQRT = squareAndRound(defaultNode.Boss.MAX_DIST_COVER_BOSS);
            defaultNode.Boss.KOJANIY_MIN_DIST_TO_LOOT_SQRT = squareAndRound(defaultNode.Boss.KOJANIY_MIN_DIST_TO_LOOT);

            defaultNode.Scattering.DIST_FROM_OLD_POINT_TO_NOT_AIM_SQRT = squareAndRound(defaultNode.Scattering.DIST_FROM_OLD_POINT_TO_NOT_AIM);

            //console.info(defaultNode);

            for (const thisRole in dbNode.botDifficulty) {

                if (thisRole == '_core' || thisRole == '_default') { // Don't process these
                    continue;
                } else if (thisRole == 'assault' || thisRole == 'cursedassault' || thisRole == 'marksman') { // These are the roles that have multiple difficulty types
                    for (const thisDifficulty in dbNode.botDifficulty[thisRole]) {
                        for (const thisKey of defineArray) {
                            debugOut(functionDebug, `Copy proto: ${thisRole}.${thisDifficulty}.${thisKey}`, 2);
                            prototypeCopy(defaultNode, dbNode.botDifficulty[thisRole][thisDifficulty], thisKey);
                        }
                    }
                } else { // Everything else only has normal difficulty
                    for (const thisKey of defineArray) {
                        debugOut(functionDebug, `Copy proto: ${thisRole}.${thisKey}`, 2);
                        prototypeCopy(defaultNode, dbNode.botDifficulty[thisRole], thisKey);
                    }
                }
            }



        }
    } else {
        debugOut(functionDebug, 'Default node undefined: dbNode.botDifficulty._default', 0, 'error');
        throw 'AE dynamicBots Fatal Error: botDifficulty/_default.js missing';
    }
}

function prototypeCopy(referenceObj, targetObj, targetKey) { // prototypeCopy is a function used by prototypeBotSettings and prototypeBotDifficulty to complete data sets
    const functionDebug = { name: 'dynamicBots.prototypeCopy', debugMode: 0 }; // Debug settings for this function

    if (!isDefined(targetObj, targetKey)) {
        debugOut(functionDebug, `copying entire key: ${targetKey}`, 3);
        targetObj[targetKey] = referenceObj[targetKey]; // If the target doesn't have an entry at all, copy the entire key
    } else {
        debugOut(functionDebug, `key exists: ${targetKey}`, 3);

        for (const thisKey in referenceObj[targetKey]) { // Iterate keys
            debugOut(functionDebug, `checking key: ${thisKey}`, 3);
            if (!isDefined(targetObj, `${targetKey}.${thisKey}`)) { // If this key doesn't exist in the target
                debugOut(functionDebug, `copying key: ${thisKey}`, 3);
                targetObj[targetKey][thisKey] = referenceObj[targetKey][thisKey];
            } else if (typeof targetObj[targetKey][thisKey] == 'object' && !Array.isArray(targetObj[targetKey][thisKey])) { // If this key does exist and isn't an array
                debugOut(functionDebug, `going deeper: ${thisKey}`, 3);
                prototypeCopy(referenceObj[targetKey], targetObj[targetKey], thisKey); // Go another level deep
            }
        }
    }
}

function squareAndRound(inputNumber) { // squareAndRound squares a number and rounds it to 3 decimal places
    return ((Math.round(Math.pow(inputNumber, 2) * 1000)) / 1000);
}

function inverseAndRound(inputNumber) { // inverseAndRound inverts a number and rounds it to 3 decimal places
    return ((Math.round((1 / inputNumber) * 1000)) / 1000);
}

function botSpawns() { // botSpawns rewrites maps to allow for customized spawns
    const functionDebug = { name: 'dynamicBots.botSpawns', debugMode: 0 }; // Debug settings for this function

    // Check that everything is defined

    const topSettings = [ // Settings outside of individual map nodes
        'bossSettings.cultistFollowers',
        'bossSettings.glukharFollowers.scout',
        'bossSettings.glukharFollowers.security',
        'bossSettings.reshalaFollowers',
        'bossSettings.sanitarFollowers',
        'bossSettings.shturmanFollowers',
    ]

    const commonSettings = [ // Settings shared by all maps
        'pmcs.pmc_Min',
        'pmcs.pmc_Max',
        'pmcs.pmc_GroupMax',
        'scavWaves.spawnChance',
        'scavWaves.initialWaves',
        'scavWaves.timedWaveDelay',
        'scavWaves.scavsPerWave_Min',
        'scavWaves.scavsPerWave_Max',
        'scavWaves.aliveScavs_Min',
        'scavWaves.aliveScavs_Max',
        'bossSpawns.spawnAnywhere',
        'bossSpawns.glukhar',
        'bossSpawns.killa',
        'bossSpawns.punisher',
        'bossSpawns.reshala',
        'bossSpawns.sanitar',
        'bossSpawns.shturman'
    ]

    const mapSettings = { // Specific settings per map
        customs: {
            bsgName: 'bigmap',
            requiredSettings: [
                'sniperScavs.spawnChance',
                'sniperScavs.aliveSnipers_Min',
                'sniperScavs.aliveSnipers_Max',
                'sniperScavs.post3Sniper',
                'bossSpawns.cultists'
            ],
            allSpawnZones: [
                "ZoneBlockPost",
                "ZoneBrige",
                "ZoneCrossRoad",
                "ZoneCustoms",
                "ZoneDormitory",
                "ZoneFactoryCenter",
                "ZoneFactorySide",
                "ZoneGasStation",
                "ZoneOldAZS",
                "ZoneScavBase",
                "ZoneTankSquare",
                "ZoneWade"
            ],
            defaultBossSpawns: 'ZoneDormitory,ZoneGasStation,ZoneScavBase',
            sniperScavs: [
                'ZoneBlockPostSniper',
                'ZoneBlockPostSniper3',
                'ZoneSnipeBrige',
                'ZoneSnipeFactory',
                'ZoneSnipeTower'
            ]
        },
        factoryDay: {
            bsgName: 'factory4_day',
            defaultBossSpawns: 'BotZone'
        },
        factoryNight: {
            bsgName: 'factory4_night',
            requiredSettings: ['bossSpawns.cultists'],
            defaultBossSpawns: 'BotZone'
        },
        interchange: {
            bsgName: 'interchange',
            allSpawnZones: [
                "ZoneCenter",
                "ZoneCenterBot",
                "ZoneGoshan",
                "ZoneIDEA",
                "ZoneIDEAPark",
                "ZoneOLI",
                "ZoneOLIPark",
                "ZonePowerStation",
                "ZoneRoad",
                "ZoneTrucks"
            ],
            defaultBossSpawns: 'ZoneCenterBot'
        },
        labs: {
            bsgName: 'laboratory',
            requiredSettings: [
                'raiders.spawnChance',
                'raiders.initialWaves',
                'raiders.timedWaveDelay',
                'raiders.raidersPerWave_Min',
                'raiders.raidersPerWave_Max',
                'raiders.groups_cargoElev',
                'raiders.groups_hangarGate',
                'raiders.groups_mainElev',
                'raiders.groups_medBlockElev',
                'raiders.groups_parkingGate'
            ],
            allSpawnZones: [
                "BotZoneBasement",
                "BotZoneFloor1",
                "BotZoneFloor2"
            ],
            defaultBossSpawns: 'BotZoneFloor1,BotZoneFloor2',
            raiderTriggers: {
                cargoElev: {
                    trigger: 'autoId_00007_EXFIL',
                    zones: 'BotZoneBasement,BotZoneFloor2'
                },
                hangarGate: {
                    trigger: 'autoId_00012_EXFIL',
                    zones: 'BotZoneFloor1,BotZoneFloor2,BotZoneGate1,BotZoneGate1,BotZoneGate1'
                },
                mainElev: {
                    trigger: 'autoId_00008_EXFIL',
                    zones: 'BotZoneBasement'
                },
                medBlockElev: {
                    trigger: 'autoId_00010_EXFIL',
                    zones: 'BotZoneBasement'
                },
                parkingGate: {
                    trigger: 'autoId_00009_EXFIL',
                    zones: 'BotZoneFloor1,BotZoneFloor2,BotZoneGate2,BotZoneGate2,BotZoneGate2'
                }
            }
        },
        reserve: {
            bsgName: 'rezervbase',
            requiredSettings: [
                'raiders.spawnChance',
                'raiders.initialWaves',
                'raiders.timedWaveDelay',
                'raiders.raidersPerWave_Min',
                'raiders.raidersPerWave_Max',
                'raiders.groups_raiderPatrol',
                'raiders.groups_extractD2',
                'raiders.groups_bunkerHermetic'
            ],
            allSpawnZones: [
                "ZoneBarrack",
                "ZoneBunkerStorage",
                "ZonePTOR1",
                "ZonePTOR2",
                "ZoneRailStrorage",
                "ZoneSubCommand",
                "ZoneSubStorage"
            ],
            defaultBossSpawns: 'ZoneBarrack,ZoneBarrack,ZoneBarrack,ZonePTOR1,ZonePTOR2,ZoneRailStrorage,ZoneRailStrorage,ZoneRailStrorage,ZoneSubStorage',
            raiderTriggers: {
                bunkerHermetic: {
                    trigger: 'autoId_00632_EXFIL',
                    zones: 'ZoneRailStrorage'
                },
                extractD2: {
                    trigger: 'autoId_00000_D2_LEVER',
                    zones: 'ZoneSubCommand'
                },
                raiderPatrol: {
                    trigger: 'raider_simple_patroling',
                    zones: 'ZoneSubCommand'
                }
            }
        },
        shoreline: {
            bsgName: 'shoreline',
            requiredSettings: [
                'sniperScavs.spawnChance',
                'sniperScavs.aliveSnipers_Min',
                'sniperScavs.aliveSnipers_Max',
                'bossSpawns.cultists'
            ],
            allSpawnZones: [
                "ZoneBunker",
                "ZoneBusStation",
                "ZoneForestGasStation",
                "ZoneForestSpawn",
                "ZoneForestTruck",
                "ZoneGasStation",
                "ZoneGreenHouses",
                "ZoneIsland",
                "ZoneMeteoStation",
                "ZonePassClose",
                "ZonePassFar",
                "ZonePort",
                "ZonePowerStation",
                "ZoneRailWays",
                "ZoneSanatorium",
                "ZoneSanatorium1",
                "ZoneSanatorium2",
                "ZoneStartVillage",
                "ZoneTunnel"
            ],
            defaultBossSpawns: 'ZoneGreenHouses,ZoneGreenHouses,ZoneGreenHouses,ZonePort,ZoneSanatorium1',
            sniperScavs: [
                'ZonePowerStationSniper',
                'ZoneBunkeSniper'
            ]
        },
        woods: {
            bsgName: 'woods',
            requiredSettings: [
                'sniperScavs.spawnChance',
                'sniperScavs.aliveSnipers_Min',
                'sniperScavs.aliveSnipers_Max',
                'bossSpawns.cultists'
            ],
            allSpawnZones: [
                "ZoneBigRocks",
                "ZoneHighRocks",
                "ZoneHouse",
                "ZoneMiniHouse",
                "ZoneRedHouse",
                "ZoneRoad",
                "ZoneScavBase2",
                "ZoneWoodCutter"
            ],
            defaultBossSpawns: 'ZoneWoodCutter',
            sniperScavs: ['ZoneHighRocks']
        }
    }

    let defineError = false;

    for (const thisSetting of topSettings) {
        if (!isDefined(dbSettingsNode, `${thisSetting}`)) {
            debugOut(functionDebug, `Setting undefined: settings.${thisSetting}`, 0, 'error');
            defineError = true;
        }
    }

    for (const thisMap in mapSettings) {
        if (isDefined(dbSettingsNode, `${thisMap}`)) {
            let thisMapNode = dbSettingsNode[thisMap];
            for (const thisKey of commonSettings) {
                if ((thisMap.startsWith('factory') && thisKey == 'bossSpawns.spawnAnywhere') || (thisMap == 'labs' && thisKey.startsWith('scavWaves')) || isDefined(thisMapNode, `${thisKey}`)) { // Only one zone on factory, no scavs on labs
                    continue;
                } else {
                    debugOut(functionDebug, `Setting undefined: settings.${thisMap}.${thisKey}`, 0, 'error');
                    defineError = true;
                }
            }
            if (isDefined(mapSettings, `${thisMap}.requiredSettings`)) { // If there are specific settings defined for this map
                for (const thisKey of mapSettings[thisMap].requiredSettings) {
                    if (isDefined(dbSettingsNode[thisMap], thisKey)) {
                        continue;
                    } else {
                        debugOut(functionDebug, `Setting undefined: settings.${thisMap}.${thisKey}`, 0, 'error');
                        defineError = true;
                    }
                }
            }
        } else {
            debugOut(functionDebug, `Setting undefined: settings.${thisMap}`, 0, 'error');
            defineError = true;
        }
    }

    if (defineError) {
        throw 'AE dynamicBots Fatal Error: Required settings missing.';
    } else {
        for (const thisMap in mapSettings) {
            //if (thisMap == 'labs') { continue; } // DEBUG
            const thisMapSettingsNode = dbSettingsNode[thisMap];
            let mapNode = global._database.locations[mapSettings[thisMap].bsgName].base;

            const waveTemplate = {
                number: 0,
                time_min: -1,
                time_max: -1,
                slots_min: 1,
                slots_max: 1,
                SpawnPoints: '',
                //BotSide: 'Savage',
                BotPreset: 'hard',
                WildSpawnType: 'assault',
                isPlayers: false,
                GroupChance: 100
            }
            mapNode.waves = []; // Erase the existing bot waves array
            mapNode.MinMaxBots = []; // Erase the existing bot limit array
            mapNode.BotLocationModifier = {};

            if (thisMap != 'labs') { // No scavs on labs
                const scavWaveRole = (dbSettingsNode.replaceScavsWith != '') ? getBotRole(dbSettingsNode.replaceScavsWith, true) : 'assault'; // If replaceScavsWith has a role specified, set bot type to that role, otherwise use assault

                const scavsPerWave_Min = Math.min(thisMapSettingsNode.scavWaves.scavsPerWave_Min, thisMapSettingsNode.scavWaves.scavsPerWave_Max);
                const scavsPerWave_Max = Math.max(thisMapSettingsNode.scavWaves.scavsPerWave_Min, thisMapSettingsNode.scavWaves.scavsPerWave_Max);

                if (scavsPerWave_Max > 0 && thisMapSettingsNode.scavWaves.spawnChance > 0 && thisMapSettingsNode.scavWaves.timedWaveDelay > 0) { // If the user even wants scavs waves on this map
                    let zoneArray = [];
                    for (let i = 1; i <= thisMapSettingsNode.scavWaves.initialWaves; i++) { // Add the instant waves
                        let randZone;
                        if (thisMap.startsWith('factory')) {
                            randZone = 'BotZone';
                        } else {
                            if (zoneArray.length <= 0) { // If all zones have been removed from the list
                                zoneArray = [...mapSettings[thisMap].allSpawnZones]; // Then repopulate the list
                            }
                            const randZoneIndex = getRandomInt(0, zoneArray.length - 1); // Select a random zone from the list and remove it from the list
                            randZone = zoneArray.splice(randZoneIndex, 1)[0];
                        }

                        let waveObj = { ...waveTemplate }; // Copy the template

                        waveObj.number = Object.keys(mapNode.waves).length + 1;
                        waveObj.slots_min = scavsPerWave_Min;
                        waveObj.slots_max = scavsPerWave_Max;
                        waveObj.SpawnPoints = randZone;
                        waveObj.WildSpawnType = scavWaveRole;
                        waveObj.GroupChance = thisMapSettingsNode.scavWaves.spawnChance;

                        mapNode.waves.push(waveObj);
                        debugOut(functionDebug, `${thisMap} -> initial wave ${waveObj.number}: ${waveObj.GroupChance}% of ${waveObj.slots_min}-${waveObj.slots_max} ${waveObj.WildSpawnType} at ${waveObj.SpawnPoints}`, 3);
                    }

                    const mapTime = mapNode.escape_time_limit * 60; // Get map time limit in seconds
                    const timedWaves = Math.floor(mapTime / thisMapSettingsNode.scavWaves.timedWaveDelay); // Calculate the number of timed waves for this map
                    debugOut(functionDebug, `${thisMap} -> mapTime: ${mapTime}, number of timed waves: ${timedWaves}`, 2);

                    for (let thisWaveNumber = 1; thisWaveNumber <= timedWaves; thisWaveNumber++) { // Add the timed waves
                        let randZone;
                        if (thisMap.startsWith('factory')) {
                            randZone = 'BotZone';
                        } else {
                            if (zoneArray.length <= 0) { // If all zones have been removed from the list
                                zoneArray = [...mapSettings[thisMap].allSpawnZones]; // Then repopulate the list
                            }
                            const randZoneIndex = getRandomInt(0, zoneArray.length - 1); // Select a random zone from the list and remove it from the list
                            randZone = zoneArray.splice(randZoneIndex, 1)[0];
                        }

                        const thisWaveTime = thisWaveNumber * thisMapSettingsNode.scavWaves.timedWaveDelay; // Calculate the time in seconds that this wave should spawn as a fraction of the total map time

                        let waveObj = { ...waveTemplate }; // Copy the template

                        waveObj.number = Object.keys(mapNode.waves).length + 1;
                        waveObj.time_min = thisWaveTime - 15;
                        waveObj.time_max = thisWaveTime + 15;
                        waveObj.slots_min = scavsPerWave_Min;
                        waveObj.slots_max = scavsPerWave_Max;
                        waveObj.SpawnPoints = randZone;
                        waveObj.WildSpawnType = scavWaveRole;
                        waveObj.GroupChance = thisMapSettingsNode.scavWaves.spawnChance;

                        mapNode.waves.push(waveObj);
                        debugOut(functionDebug, `${thisMap} -> timed wave ${waveObj.number}: ${waveObj.GroupChance}% of ${waveObj.slots_min}-${waveObj.slots_max} ${waveObj.WildSpawnType} at ${waveObj.SpawnPoints} between ${waveObj.time_min} & ${waveObj.time_max}`, 3);
                    }

                    mapNode.MinMaxBots.push({ min: thisMapSettingsNode.scavWaves.aliveScavs_Min, max: thisMapSettingsNode.scavWaves.aliveScavs_Max, WildSpawnType: scavWaveRole }); // Scav bot spawn limits

                    const maxBotsToCache = scavsPerWave_Max * (thisMapSettingsNode.scavWaves.initialWaves + timedWaves); // Calculate the number of bots to be cached when a map is loaded
                    if (!isDefined(dbNode.botPreCache, `${scavWaveRole}`) || dbNode.botPreCache[scavWaveRole] < maxBotsToCache) {
                        dbNode.botPreCache[scavWaveRole] = Number(maxBotsToCache);
                    }
                }
            }

            if (isDefined(mapSettings[thisMap], 'sniperScavs') && thisMapSettingsNode.sniperScavs.spawnChance > 0) { // If sniper scavs are supposed to spawn on this map and user wants sniper scavs to spawn
                let maxBotsToCache = 0;
                for (const thisWave of mapSettings[thisMap].sniperScavs) {
                    if (thisMap == 'customs' && thisWave == 'ZoneBlockPostSniper3' && !thisMapSettingsNode.sniperScavs.post3Sniper) { // If post3Sniper is false, skip this wave
                        continue;
                    }

                    let waveObj = { ...waveTemplate }; // Copy the template

                    waveObj.number = Object.keys(mapNode.waves).length + 1;
                    if (thisMap == 'shoreline') {
                        if (thisWave == 'ZoneBunkeSniper') { // Chance of only one sniper on sniper rock next to the bunker
                            waveObj.slots_min = 1;
                        } else {
                            waveObj.slots_min = 2; // Always 2 snipers on the power station
                        }
                        waveObj.slots_max = 2;
                    }
                    waveObj.SpawnPoints = thisWave;
                    waveObj.WildSpawnType = 'marksman';
                    waveObj.GroupChance = thisMapSettingsNode.sniperScavs.spawnChance;

                    mapNode.waves.push(waveObj);
                    maxBotsToCache += waveObj.slots_max;
                    debugOut(functionDebug, `${thisMap} -> sniper wave ${waveObj.number}: ${waveObj.GroupChance}% of ${waveObj.slots_min}-${waveObj.slots_max} ${waveObj.WildSpawnType} at ${waveObj.SpawnPoints}`, 3);
                }

                mapNode.MinMaxBots.push({ min: thisMapSettingsNode.sniperScavs.aliveSnipers_Min, max: thisMapSettingsNode.sniperScavs.aliveSnipers_Max, WildSpawnType: 'marksman' }); // Sniper scav limits

                if (!isDefined(dbNode.botPreCache, 'marksman') || dbNode.botPreCache['marksman'] < maxBotsToCache) {
                    dbNode.botPreCache['marksman'] = Number(maxBotsToCache);
                }
            }

            mapNode.BossLocationSpawn = []; // Clear the current boss spawn object

            if (isDefined(thisMapSettingsNode, 'raiders') && thisMapSettingsNode.raiders.spawnChance > 0 && thisMapSettingsNode.raiders.raidersPerWave_Max > 0 && thisMapSettingsNode.raiders.timedWaveDelay > 0) { // If raiders are supposed to spawn on this map and user wants raiders to spawn
                const raidersPerWave_Min = Math.min(thisMapSettingsNode.raiders.raidersPerWave_Min, thisMapSettingsNode.raiders.raidersPerWave_Max);
                const raidersPerWave_Max = Math.max(thisMapSettingsNode.raiders.raidersPerWave_Min, thisMapSettingsNode.raiders.raidersPerWave_Max);

                let zoneArray = [];
                for (let i = 1; i <= thisMapSettingsNode.raiders.initialWaves; i++) { // Add the instant waves
                    let randZone;
                    if (thisMap.startsWith('factory')) {
                        randZone = 'BotZone';
                    } else {
                        if (zoneArray.length <= 0) { // If all zones have been removed from the list
                            zoneArray = [...mapSettings[thisMap].allSpawnZones]; // Then repopulate the list
                        }
                        const randZoneIndex = getRandomInt(0, zoneArray.length - 1); // Select a random zone from the list and remove it from the list
                        randZone = zoneArray.splice(randZoneIndex, 1)[0];
                    }

                    let waveObj = { ...waveTemplate }; // Copy the template

                    waveObj.number = Object.keys(mapNode.waves).length + 1;
                    waveObj.slots_min = raidersPerWave_Min;
                    waveObj.slots_max = raidersPerWave_Max;
                    waveObj.SpawnPoints = randZone;
                    waveObj.WildSpawnType = 'pmcBot';
                    waveObj.GroupChance = thisMapSettingsNode.raiders.spawnChance;

                    mapNode.waves.push(waveObj);
                    debugOut(functionDebug, `${thisMap} -> initial wave ${waveObj.number}: ${waveObj.GroupChance}% of ${waveObj.slots_min}-${waveObj.slots_max} ${waveObj.WildSpawnType} at ${waveObj.SpawnPoints}`, 3);
                }

                const mapTime = mapNode.escape_time_limit * 60; // Get map time limit in seconds
                const timedWaves = Math.floor(mapTime / thisMapSettingsNode.raiders.timedWaveDelay); // Calculate the number of timed waves for this map
                debugOut(functionDebug, `${thisMap} -> mapTime: ${mapTime}, number of timed waves: ${timedWaves}`, 2);

                for (let thisWaveNumber = 1; thisWaveNumber <= timedWaves; thisWaveNumber++) { // Add the timed waves
                    let randZone;
                    if (thisMap.startsWith('factory')) {
                        randZone = 'BotZone';
                    } else {
                        if (zoneArray.length <= 0) { // If all zones have been removed from the list
                            zoneArray = [...mapSettings[thisMap].allSpawnZones]; // Then repopulate the list
                        }
                        const randZoneIndex = getRandomInt(0, zoneArray.length - 1); // Select a random zone from the list and remove it from the list
                        randZone = zoneArray.splice(randZoneIndex, 1)[0];
                    }

                    const thisWaveTime = thisWaveNumber * thisMapSettingsNode.raiders.timedWaveDelay; // Calculate the time in seconds that this wave should spawn as a fraction of the total map time

                    let waveObj = { ...waveTemplate }; // Copy the template

                    waveObj.number = Object.keys(mapNode.waves).length + 1;
                    waveObj.time_min = thisWaveTime - 15;
                    waveObj.time_max = thisWaveTime + 15;
                    waveObj.slots_min = raidersPerWave_Min;
                    waveObj.slots_max = raidersPerWave_Max;
                    waveObj.SpawnPoints = randZone;
                    waveObj.WildSpawnType = 'pmcBot';
                    waveObj.GroupChance = thisMapSettingsNode.raiders.spawnChance;

                    mapNode.waves.push(waveObj);
                    debugOut(functionDebug, `${thisMap} -> timed wave ${waveObj.number}: ${waveObj.GroupChance}% of ${waveObj.slots_min}-${waveObj.slots_max} ${waveObj.WildSpawnType} at ${waveObj.SpawnPoints} between ${waveObj.time_min} & ${waveObj.time_max}`, 3);
                }

                let raiderTriggerCount = 0;
                if (isDefined(mapSettings[thisMap], 'raiderTriggers')) {
                    let raiderEscortString = '0';
                    if (raidersPerWave_Min == raidersPerWave_Max) {
                        raiderEscortString = String(raidersPerWave_Max - 1); // Escorts are max minus one since the escorts accompany one bot
                    } else {
                        for (let i = 0; i < raidersPerWave_Max - raidersPerWave_Min + 1; i++) {
                            if (i == 0) {
                                raiderEscortString = String(raidersPerWave_Min - 1);
                            } else {
                                raiderEscortString += `,${raidersPerWave_Min - 1 + i}`;
                            }
                        }
                    }

                    const raiderTemplate = {
                        BossName: 'pmcBot',
                        BossChance: thisMapSettingsNode.raiders.spawnChance,
                        BossZone: '',
                        //BossSide: 'Savage',
                        BossPlayer: false,
                        BossDifficult: 'hard',
                        BossEscortType: 'pmcBot',
                        BossEscortDifficult: 'hard',
                        BossEscortAmount: raiderEscortString,
                        Time: -1,
                        TriggerId: '',
                        TriggerName: 'interactObject',
                        Delay: 0
                    }

                    for (const thisTrigger in mapSettings[thisMap].raiderTriggers) {
                        const thisGroupCount = thisMapSettingsNode.raiders[`groups_${thisTrigger}`];
                        if (thisGroupCount > 0) {
                            raiderTriggerCount += thisGroupCount;

                            for (let i = 0; i < thisGroupCount; i++) {
                                let raiderObj = { ...raiderTemplate }; // Copy the template

                                raiderObj.BossZone = mapSettings[thisMap].raiderTriggers[thisTrigger].zones;
                                raiderObj.TriggerId = mapSettings[thisMap].raiderTriggers[thisTrigger].trigger;

                                mapNode.BossLocationSpawn.push(raiderObj);
                                debugOut(functionDebug, `${thisMap} -> Raider spawn ${raiderObj.BossChance}% chance with group of ${raiderObj.BossEscortAmount} at ${raiderObj.BossZone} on trigger ${raiderObj.TriggerId}`, 3);
                            }
                        }
                    }
                }

                const maxBotsToCache = raidersPerWave_Max * (thisMapSettingsNode.raiders.initialWaves + timedWaves + raiderTriggerCount); // Calculate the number of bots to be cached when a map is loaded
                if (!isDefined(dbNode.botPreCache, 'pmcBot') || dbNode.botPreCache['pmcBot'] < maxBotsToCache) {
                    dbNode.botPreCache['pmcBot'] = Number(maxBotsToCache);
                }
            }

            const pmc_Min = Math.min(thisMapSettingsNode.pmcs.pmc_Min, thisMapSettingsNode.pmcs.pmc_Max);
            const pmc_Max = Math.max(thisMapSettingsNode.pmcs.pmc_Min, thisMapSettingsNode.pmcs.pmc_Max);

            if (pmc_Max > 0 && global._database.gameplayConfig.bots.pmc.enabled) { // If the user wants PMCs to spawn on this map
                for (const thisSpawn of mapNode.SpawnPointParams) {
                    if (thisSpawn.Categories.includes('Bot')) {
                        //thisSpawn.Sides = ['All'];
                        thisSpawn.Categories = ['Boss', 'Bot']; // Allow PMC bots to spawn
                    }
                }

                const pmcTemplate = {
                    BossName: 'bossTest',
                    BossChance: 100,
                    BossZone: '',
                    BossPlayer: false,
                    BossDifficult: 'hard',
                    BossEscortType: 'followerGluharAssault',
                    BossEscortDifficult: 'hard',
                    BossEscortAmount: '0',
                    Time: -1,
                    TriggerId: '',
                    TriggerName: '',
                    Delay: 0
                }

                let zoneArray;
                if (!thisMap.startsWith('factory')) {
                    zoneArray = [...mapSettings[thisMap].allSpawnZones];
                }

                let numBossTest = 0;
                for (let i = 1; i <= pmc_Min; i++) {
                    numBossTest++;
                    let randZones;
                    if (thisMap.startsWith('factory')) {
                        randZones = 'BotZone';
                    } else {
                        for (let z = 0; z < 3; z++) { // Select 3 random zones where this PMC group can spawn
                            const randZoneIndex = getRandomInt(0, zoneArray.length - 1); // Select a random zone from the list and remove it from the list
                            if (z == 0) {
                                randZones = zoneArray[randZoneIndex];
                            } else {
                                if (randZones.includes(zoneArray[randZoneIndex])) { // Don't add duplicates
                                    z--;
                                    continue;
                                } else {
                                    randZones += `,${zoneArray[randZoneIndex]}`;
                                }
                            }
                        }
                    }

                    let pmcEscorts = 0;
                    if (thisMapSettingsNode.pmcs.pmc_GroupMax > 1 && (pmc_Min - i) > 1) {
                        pmcEscorts = getRandomInt(0, Math.min(pmc_Min - i, thisMapSettingsNode.pmcs.pmc_GroupMax - 1)); // Set group size to a random number between 0 escort and whichever is smaller: the remaining bots left or the max group size
                    }
                    debugOut(functionDebug, `${thisMap} -> pmc_Min - i: ${pmc_Min - i}   thisMapSettingsNode.pmcs.pmc_GroupMax - 1: ${thisMapSettingsNode.pmcs.pmc_GroupMax - 1}   pmcEscorts: ${pmcEscorts}`, 3);

                    let pmcObj = { ...pmcTemplate }; // Copy the template

                    if (pmcEscorts > 0) {
                        pmcObj.Supports = [{
                            BossEscortType: 'followerGluharAssault',
                            BossEscortDifficult: ['hard'],
                            BossEscortAmount: String(pmcEscorts)
                        }];
                    }
                    pmcObj.BossZone = randZones;
                    pmcObj.BossEscortAmount = String(pmcEscorts);

                    mapNode.BossLocationSpawn.push(pmcObj);
                    debugOut(functionDebug, `${thisMap} -> PMC spawn ${pmcObj.BossChance}% chance with group of ${pmcObj.BossEscortAmount} at ${pmcObj.BossZone} near time ${pmcObj.Time}`, 3);

                    if (pmcEscorts > 0) {
                        i += pmcEscorts; // i represents the total number of bots spawned and iterates by 1 every loop, so add all these escorts so we don't spawn too many total bots
                    }
                }

                for (let i = pmc_Min + 1; i <= pmc_Max; i++) {
                    numBossTest++;
                    let randZones;
                    if (thisMap.startsWith('factory')) {
                        randZones = 'BotZone';
                    } else {
                        for (let z = 0; z < 3; z++) { // Select 3 random zones where this PMC group can spawn
                            const randZoneIndex = getRandomInt(0, zoneArray.length - 1); // Select a random zone from the list and remove it from the list
                            if (z == 0) {
                                randZones = zoneArray[randZoneIndex];
                            } else {
                                if (randZones.includes(zoneArray[randZoneIndex])) { // Don't add duplicates
                                    z--;
                                    continue;
                                } else {
                                    randZones += `,${zoneArray[randZoneIndex]}`;
                                }
                            }
                        }
                    }

                    let pmcEscorts = 0;
                    if (thisMapSettingsNode.pmcs.pmc_GroupMax > 1 && (pmc_Max - i) > 1) {
                        pmcEscorts = getRandomInt(0, Math.min(pmc_Max - i, thisMapSettingsNode.pmcs.pmc_GroupMax - 1)); // Set group size to a random number between 0 escort and whichever is smaller: the remaining bots left or the max group size
                    }
                    debugOut(functionDebug, `${thisMap} -> pmc_Max - i: ${pmc_Max - i}   thisMapSettingsNode.pmcs.pmc_GroupMax - 1: ${thisMapSettingsNode.pmcs.pmc_GroupMax - 1}   pmcEscorts: ${pmcEscorts}`, 3);

                    let pmcObj = { ...pmcTemplate }; // Copy the template

                    if (pmcEscorts > 0) {
                        pmcObj.Supports = [{
                            BossEscortType: 'followerGluharAssault',
                            BossEscortDifficult: ['hard'],
                            BossEscortAmount: String(pmcEscorts)
                        }];
                    }
                    pmcObj.BossChance = 50; // Spawn groups between pmc_Min and pmc_Max at 50% to introduce variability in the number of PMCs that spawn per map
                    pmcObj.BossZone = randZones;
                    pmcObj.BossEscortAmount = String(pmcEscorts);

                    mapNode.BossLocationSpawn.push(pmcObj);
                    debugOut(functionDebug, `${thisMap} -> PMC spawn ${pmcObj.BossChance}% of with a group of ${pmcObj.BossEscortAmount} at ${pmcObj.BossZone} near time ${pmcObj.Time}`, 3);

                    if (pmcEscorts > 0) {
                        i += pmcEscorts; // i represents the number of bots spawned and iterates by 1 every loop so add the number of bots minus one to i so we don't spawn too many pmc bots
                    }
                }

                //mapNode.MinMaxBots.push({ min: thisMapSettingsNode.pmcs.alivePMCs_Min, max: thisMapSettingsNode.pmcs.alivePMCs_Max, WildSpawnType: 'followerGluharAssault' }); // PMC limits
                if (!isDefined(dbNode.botPreCache, 'bossTest') || dbNode.botPreCache['bossTest'] < numBossTest) {
                    dbNode.botPreCache['bossTest'] = Number(numBossTest);
                }
                if (!isDefined(dbNode.botPreCache, 'followerGluharAssault') || dbNode.botPreCache['followerGluharAssault'] < pmc_Max - numBossTest) {
                    dbNode.botPreCache['followerGluharAssault'] = Number(pmc_Max - numBossTest);
                }
            } else {
                debugOut(functionDebug, `PMCs disabled on map ${thisMap}`, 2);
            }

            bossLoop:
            for (const thisBoss in thisMapSettingsNode.bossSpawns) {
                if (thisBoss == 'spawnAnywhere') { // This is a setting rather than a boss
                    continue bossLoop;
                } else if (thisMapSettingsNode.bossSpawns[thisBoss] > 0) { // If this boss is set to spawn
                    let thisBossObj = {
                        BossName: '',
                        BossChance: thisMapSettingsNode.bossSpawns[thisBoss],
                        BossZone: '',
                        //BossSide: 'Savage',
                        BossPlayer: false,
                        BossDifficult: 'hard',
                        BossEscortType: 'assault',
                        BossEscortDifficult: 'hard',
                        BossEscortAmount: '0',
                        Time: -1,
                        TriggerId: '',
                        TriggerName: '',
                        Delay: 0
                    }

                    if (thisMapSettingsNode.bossSpawns.spawnAnywhere) { // If bosses are set to spawn anywhere
                        const zoneArray = [...mapSettings[thisMap].allSpawnZones];

                        let randZones;
                        for (let z = 0; z < 3; z++) { // Select 3 random zones where this boss group can spawn
                            const randZoneIndex = getRandomInt(0, zoneArray.length - 1); // Select a random zone from the list and remove it from the list
                            if (z == 0) {
                                randZones = zoneArray[randZoneIndex];
                            } else {
                                if (randZones.includes(zoneArray[randZoneIndex])) { // Don't add duplicates
                                    z--;
                                    continue;
                                } else {
                                    randZones += `,${zoneArray[randZoneIndex]}`;
                                }
                            }
                        }

                        thisBossObj.BossZone = randZones;
                    } else {
                        thisBossObj.BossZone = mapSettings[thisMap].defaultBossSpawns; // Otherwise use default boss spawns
                    }

                    switch (thisBoss) {
                        case 'cultists':
                            thisBossObj.BossName = 'sectantPriest';
                            thisBossObj.BossEscortType = 'sectantWarrior';
                            break;
                        case 'glukhar':
                            thisBossObj.BossName = 'bossGluhar';
                            thisBossObj.BossEscortType = 'followerGluharSecurity';
                            break;
                        case 'killa':
                            thisBossObj.BossName = 'bossKilla';
                            break;
                        case 'punisher':
                            thisBossObj.BossName = 'followerGluharSnipe';
                            break;
                        case 'reshala':
                            thisBossObj.BossName = 'bossBully';
                            thisBossObj.BossEscortType = 'followerBully';
                            break;
                        case 'sanitar':
                            thisBossObj.BossName = 'bossSanitar';
                            thisBossObj.BossEscortType = 'followerSanitar';
                            break;
                        case 'shturman':
                            thisBossObj.BossName = 'bossKojaniy';
                            thisBossObj.BossEscortType = 'followerKojaniy';
                            break;
                        default:
                            debugOut(functionDebug, `Setting undefined: Unknown boss ${thisBoss}`, 0, 'error');
                            continue bossLoop;
                    }

                    mapNode.BossLocationSpawn.push(thisBossObj);
                    //mapNode.MinMaxBots.push({ min: 0, max: 1, WildSpawnType: thisBossObj.BossName }); // boss limit
                    if (!isDefined(dbNode.botPreCache, `${thisBossObj.BossName}`) || dbNode.botPreCache[thisBossObj.BossName] < 1) {
                        dbNode.botPreCache[thisBossObj.BossName] = 1;
                    }

                    if (thisBoss == 'killa' || thisBoss == 'punisher') {
                        thisBossObj.BossEscortAmount = '0';
                    } else if (thisBoss == 'cultists') {
                        thisBossObj.BossEscortAmount = String(dbSettingsNode.bossSettings.cultistFollowers);

                        if (typeof dbSettingsNode.bossSettings.cultistFollowers == 'number') {
                            //mapNode.MinMaxBots.push({ min: 0, max: thisBossObj.BossEscortAmount, WildSpawnType: thisBossObj.BossEscortType }); // sectantWarrior limit
                            if (!isDefined(dbNode.botPreCache, `${thisBossObj.BossEscortType}`) || dbNode.botPreCache[thisBossObj.BossEscortType] < dbSettingsNode.bossSettings.cultistFollowers) {
                                dbNode.botPreCache[thisBossObj.BossEscortType] = Number(dbSettingsNode.bossSettings.cultistFollowers);
                            }
                        } else {
                            const followerSpawnArray = dbSettingsNode.bossSettings.cultistFollowers.split(',');
                            const followerMax = Math.max(...followerSpawnArray); // Find the largest spawn number
                            if (!isDefined(dbNode.botPreCache, `${thisBossObj.BossEscortType}`) || dbNode.botPreCache[thisBossObj.BossEscortType] < followerMax) {
                                dbNode.botPreCache[thisBossObj.BossEscortType] = Number(followerMax);
                            }
                        }
                    } else if (thisBoss == 'glukhar') {
                        const glukharNode = dbSettingsNode.bossSettings.glukharFollowers;
                        if (typeof glukharNode.scout != 'number') {
                            throw 'modSettings.bossSettings.glukharFollowers.scout is not an integer';
                        } else if (typeof glukharNode.security != 'number') {
                            throw 'modSettings.bossSettings.glukharFollowers.security is not an integer';
                        }

                        thisBossObj.BossEscortAmount = String(glukharNode.scout + glukharNode.security);

                        if (glukharNode.scout > 0) {
                            thisBossObj.Supports = [{
                                BossEscortType: 'followerGluharScout',
                                BossEscortDifficult: ['hard'],
                                BossEscortAmount: String(glukharNode.scout)
                            }];
                            //mapNode.MinMaxBots.push({ min: 0, max: glukharNode.scout, WildSpawnType: 'followerGluharScout' }); // followerGluharScout limit
                            if (!isDefined(dbNode.botPreCache, 'followerGluharScout') || dbNode.botPreCache['followerGluharScout'] < glukharNode.scout) {
                                dbNode.botPreCache['followerGluharScout'] = Number(glukharNode.scout);
                            }
                        }

                        if (glukharNode.security > 0) {
                            if (!isDefined(thisBossObj, 'Supports')) {
                                thisBossObj.Supports = [];
                            }
                            thisBossObj.Supports.push({
                                BossEscortType: 'followerGluharSecurity',
                                BossEscortDifficult: ['hard'],
                                BossEscortAmount: String(glukharNode.security)
                            });
                            //mapNode.MinMaxBots.push({ min: 0, max: glukharNode.security, WildSpawnType: 'followerGluharSecurity' }); // followerGluharScout limit
                            if (!isDefined(dbNode.botPreCache, 'followerGluharSecurity') || dbNode.botPreCache['followerGluharSecurity'] < glukharNode.security) {
                                dbNode.botPreCache['followerGluharSecurity'] = Number(glukharNode.security);
                            }
                        }
                    } else {
                        thisBossObj.BossEscortAmount = String(dbSettingsNode.bossSettings[`${thisBoss}Followers`]);

                        if (thisBossObj.BossEscortAmount > 0) {
                            thisBossObj.Supports = [{
                                BossEscortType: thisBossObj.BossEscortType,
                                BossEscortDifficult: ['hard'],
                                BossEscortAmount: String(thisBossObj.BossEscortAmount)
                            }];
                            //mapNode.MinMaxBots.push({ min: 0, max: thisBossObj.BossEscortAmount, WildSpawnType: thisBossObj.BossEscortType }); // Boss follower limit
                            if (!isDefined(dbNode.botPreCache, `${thisBossObj.BossEscortType}`) || dbNode.botPreCache[thisBossObj.BossEscortType] < thisBossObj.BossEscortAmount) {
                                dbNode.botPreCache[thisBossObj.BossEscortType] = Number(thisBossObj.BossEscortAmount);
                            }
                        }
                    }
                    debugOut(functionDebug, `${thisMap} -> Boss spawn ${thisBossObj.BossChance}% of ${thisBossObj.BossName} with a group of ${thisBossObj.BossEscortAmount} at ${thisBossObj.BossZone} near time ${thisBossObj.Time}`, 3);
                }
            }

            //console.info(mapNode.waves);
            //console.info(mapNode.MinMaxBots);
            //console.info(mapNode.SpawnPointParams);
            //console.info(mapNode.BossLocationSpawn);
        }

        //fs.writeFileSync(aeNode.constants.serverDir + '/user/cache/locations.json', JSON.stringify(global._database.locations, null, '\t'), 'utf8'); // Write changes to cache (unnecessary for functionality, so changes can be viewed)
    }

}

function botPreCache() { // botPreCache sets bot pre-cache tables
    const functionDebug = { name: 'dynamicBots.botPreCache', debugMode: 0 }; // Debug settings for this function

    for (const thisSetting in dbSettingsNode.botCaching) {
        const thisRole = (getBotRole(thisSetting, true)); // Get BSG name for this role

        if (Number.isInteger(dbSettingsNode.botCaching[thisSetting])) {
            debugOut(functionDebug, `Overrode auto cache setting: ${thisRole}: ${dbNode.botPreCache[thisRole]} -> ${Number(dbSettingsNode.botCaching[thisSetting])}`, 2);
            dbNode.botPreCache[thisRole] = Number(dbSettingsNode.botCaching[thisSetting]);
        } else if (!isDefined(dbNode.botPreCache, `${thisRole}`)) {
            dbNode.botPreCache[thisRole] = 1;
        }
    }
}

exports.generate = (request, sessionID) => { // generate responds to the client with an array of all of the requested bots
    //console.info(request);
    let returnArray = [];
    for (const condition of request.conditions) { // Iterate through all requests for bots
        for (let i = 0; i < condition.Limit; i++) { // Generate the number of bots requested
            const botRole = getBotRole(condition.Role); // Convert BSG bot role into DBG bot role

            let thisBot = utility.wipeDepend(generateBot(botRole, sessionID));

            thisBot.Info.Settings.Role = condition.Role; // Make sure role matches so we don't get broken waves
            thisBot.Info.Settings.BotDifficulty = condition.Difficulty; // Set bot difficulty

            if (writeDebugBots) {
                fs.mkdirSync(`${aeNode.constants.modDir}/debug/${sessionID}`, { recursive: true });
                fs.writeFileSync(`${aeNode.constants.modDir}/debug/${sessionID}/${Date.now()}.json`, JSON.stringify(thisBot, null, '\t'), 'utf8');
            }

            returnArray.push(thisBot);
        }
    }

    return returnArray;
}

exports.generatePlayerScav = (sessionID) => { // generatePlayerScav responds to the client with a player scav loadout
    //generateLotsOfBots(sessionID, 500); // Generate lots of bots for debugging

    let thisBot
    if (dbSettingsNode.replacePlayerScavWith != '') {
        thisBot = utility.wipeDepend(generateBot(dbSettingsNode.replacePlayerScavWith, sessionID, true));
    } else {
        thisBot = utility.wipeDepend(generateBot('playerscav', sessionID, true));
    }

    thisBot.Info.Settings.Role = 'assault'; // Make sure role is accurate

    if (writeDebugBots) {
        fs.mkdirSync(`${aeNode.constants.modDir}/debug/${sessionID}`, { recursive: true });
        fs.writeFileSync(`${aeNode.constants.modDir}/debug/${sessionID}/${Date.now()}.json`, JSON.stringify(thisBot, null, '\t'), 'utf8');
    }

    return thisBot;
}

exports.getBotDifficulty = (botRole, botDifficulty) => { // getBotDifficulty responds to the client by fetching bot difficulty settings from the global cache
    const functionDebug = { name: 'dynamicBots.getBotDifficulty', debugMode: 0 }; // Debug settings for this function
    const botRoleLower = botRole.toLowerCase();

    if (botRoleLower == 'core') {
        debugOut(functionDebug, 'Returning dbNode.botDifficulty._core', 2);
        return dbNode.botDifficulty._core; // botCore is basic bot reaction data shared among all bots
    } else {
        if (botRoleLower == 'assault' || botRoleLower == 'cursedassault' || botRoleLower == 'marksman') {
            debugOut(functionDebug, `Returning dbNode.botDifficulty.${botRoleLower}.${botDifficulty}`, 2);
            return dbNode.botDifficulty[botRoleLower][botDifficulty]; // Return bot role and difficulty
        } else {
            if (isDefined(dbNode.botDifficulty, `${botRoleLower}`)) { // If the requested role exists
                debugOut(functionDebug, `Returning dbNode.botDifficulty.${botRoleLower}`, 2);
                return dbNode.botDifficulty[botRoleLower];
            } else {
                debugOut(functionDebug, 'Returning dbNode.botDifficulty._default', 2);
                return dbNode.botDifficulty._default; // Else return the default file
            }
        }
    }
}

exports.getBotLimit = (botRole) => { // getBotLimit responds to the client by fetching bot limit settings from the global cache (set in gameplay.json)
    const functionDebug = { name: 'dynamicBots.getBotLimit', debugMode: 0 }; // Debug settings for this function
    if (isDefined(dbNode, 'botPreCache') && isDefined(dbNode.botPreCache, `${botRole}`)) {
        const thisBotLimit = Number(dbNode.botPreCache[botRole]);
        if (isDefined(dbSettingsNode, 'botMaxCache') && thisBotLimit > dbSettingsNode.botMaxCache) {
            debugOut(functionDebug, `Role ${botRole} limit too high: ${thisBotLimit} -> limiting to botMaxCache: ${dbSettingsNode.botMaxCache}`, 2);
            return dbSettingsNode.botMaxCache;
        } else {
            debugOut(functionDebug, `Role: ${botRole} -> limit: ${thisBotLimit}`, 2);
            return thisBotLimit;
        }
    } else {
        debugOut(functionDebug, `Role ${botRole} undefined, botMaxCache undefined, limiting to 1`, 2);
        return 1;
    }
}

function getBotRole(botRole, reverse = false) { // getBotRole translates BSG's bot roles to DynamicBotGen roles used by this script, such as in botSettings. If reverse is toggled, this function accepts DBG bot roles and returns BSG bot roles
    const botRoleLower = botRole.toLowerCase();

    let roleArray;
    if (reverse) { // Receive DBG bot role, return BSG bot role
        roleArray = {
            bear: 'followerGluharAssault',
            cultistpriest: 'sectantPriest',
            cultistwarrior: 'sectantWarrior',
            glukhar: 'bossGluhar',
            glukhar_scout: 'followerGluharScout',
            glukhar_security: 'followerGluharSecurity',
            killa: 'bossKilla',
            pmc: 'followerGluharAssault',
            punisher: 'followerGluharSnipe',
            raider: 'pmcBot',
            reshala: 'bossBully',
            reshala_guard: 'followerBully',
            sanitar: 'bossSanitar',
            sanitar_guard: 'followerSanitar',
            scav: 'assault',
            shturman: 'bossKojaniy',
            shturman_guard: 'followerKojaniy',
            sniperscav: 'marksman',
            usec: 'followerGluharAssault'
        };
    } else { // Receive BSG bot role, return DBG bot role
        if (botRoleLower == 'bosstest' || botRoleLower == 'followergluharassault') {
            return (randomByPercent(global._database.gameplayConfig.bots.pmc.usecChance)) ? 'usec' : 'bear'; // Roll whether this bot is USEC or Bear based on usecChance setting
        } else {
            roleArray = {
                assault: 'scav',
                bossbully: 'reshala',
                bossgluhar: 'glukhar',
                bosskilla: 'killa',
                bosskojaniy: 'shturman',
                bosssanitar: 'sanitar',
                followerbully: 'reshala_guard',
                followergluharscout: 'glukhar_scout',
                followergluharsecurity: 'glukhar_security',
                followergluharsnipe: 'punisher',
                followerkojaniy: 'shturman_guard',
                followersanitar: 'sanitar_guard',
                marksman: 'sniperscav',
                pmcbot: 'raider',
                sectantpriest: 'cultistpriest',
                sectantwarrior: 'cultistwarrior'
            };
        }
    }

    if (isDefined(roleArray, botRoleLower)) {
        return roleArray[botRoleLower];
    } else {
        return botRole;
    }
}

function generateBot(role, sessionID, isPlayerBot = false, botLevelOverride = false) { // generateBot creates a new bot in the specified role
    const functionDebug = { name: 'dynamicBots.generateBot', debugMode: 0 }; // Debug settings for this function

    let thisBot = utility.wipeDepend(global._database.core.botBase); // Copy bot base
    const botRole = role.toLowerCase();
    const pmcData = profile_f.handler.getPmcProfile(sessionID); // Read PMC profile

    // Load bot settings from Dynamic Bot Gen settings based on bot's role
    let dbgBotSettings;

    if (botRole == 'cursedassault' && isDefined(dbSettingsNode, 'replaceCursedWith')) {
        if (dbSettingsNode.replaceCursedWith != '' && isDefined(dbNode, `botSettings.${dbSettingsNode.replaceCursedWith}`)) {
            dbgBotSettings = dbNode.botSettings[dbSettingsNode.replaceCursedWith];
            debugOut(functionDebug, `Bot settings loaded for role: ${botRole} -> (${dbSettingsNode.replaceCursedWith})`, 2);
        } else {
            dbgBotSettings = dbNode.botSettings.scav;
            debugOut(functionDebug, `replaceCursedWith Bot role does not exist: ${botRole}; using scav settings`, 1, 'warning');
        }
    } else if (isDefined(dbNode, `botSettings.${botRole}`)) { // If this role exists in settings
        dbgBotSettings = dbNode.botSettings[botRole];
        debugOut(functionDebug, `Bot settings loaded for role: ${botRole}`, 2);
    } else { // Otherwise use _default
        dbgBotSettings = dbNode.botSettings._default;
        debugOut(functionDebug, `Bot role does not exist: ${botRole}; using _default settings`, 1, 'warning');
    }

    // Bot account ID (for dogtag)
    newBotID(thisBot);
    debugOut(functionDebug, `Bot AID: ${thisBot.aid}`, 2);

    if (botRole == 'usec') {
        thisBot.Info.Side = 'Usec';
    } else if (botRole == 'bear') {
        thisBot.Info.Side = 'Bear';
    } else {
        thisBot.Info.Side = 'Savage';
    }

    // Bot level/exp
    if (botLevelOverride) {
        thisBot.Info.Level = botLevelOverride;
        const expTable = globalsDB.config.exp.level.exp_table; // Read EXP table so we know how much exp to give a bot of whichever level
        thisBot.Info.Experience = 0;
        for (let i = 0; i < thisBot.Info.Level; i++) {
            thisBot.Info.Experience += expTable[i].exp; // Add up each experience bracket so exp matches level
        }
        if (botLevelOverride < expTable.length - 1) { // If this bot isn't at max level
            thisBot.Info.Experience += getRandomInt(0, expTable[botLevelOverride].exp - 1); // Add a random amount of experience to their current level bar
        }
    } else {
        if (botRole == 'playerscav') { // Playerscav should be same level as player
            thisBot.Info.Level = pmcData.Info.Level;
            thisBot.Info.Experience = pmcData.Info.Experience;
        } else {
            const botLevelGen = randomBotLevel(dbgBotSettings, pmcData); // Generate a random level and experience for this bot based on settings in the bot file and mod settings
            thisBot.Info.Level = botLevelGen.botLevel;
            thisBot.Info.Experience = botLevelGen.botExperience;
        }
    }
    debugOut(functionDebug, `Bot level: ${thisBot.Info.Level} --> ${thisBot.Info.Experience} experience`, 2);
    thisBot.Info.Settings.Experience = getRandomInt(dbgBotSettings.experience.XPreward_Min, dbgBotSettings.experience.XPreward_Max); // Set bot exp reward (for killing)

    // Bot health
    newBotHealth(thisBot, dbgBotSettings.health); // Create bot health object based on DBG settings

    // Bot name
    let nameSet;
    if (isDefined(dbNode, `botNames.${dbgBotSettings.names.nameSet}`)) {
        nameSet = dbgBotSettings.names.nameSet;
    } else {
        nameSet = 'russian';
    }

    if (randomByPercent(dbgBotSettings.names.chanceForNickname)) { // If this bot's percent chance for having a nickname rolled true
        let nickName;
        if (isDefined(dbgBotSettings.names, 'forcedNickname')) {
            nickName = dbgBotSettings.names.forcedNickname;
        } else {
            nickName = getRandomFromArray(dbNode.botNames[nameSet].nickNames);
        }

        if (randomByPercent(dbgBotSettings.names.addNumbersAfterNickname)) { // If there's a chance of numbers after the nickname
            const randDigits = getRandomInt(1, 5);

            let digitString = '';
            for (let thisDigit = 0; thisDigit < randDigits; thisDigit++) {
                digitString += String(getRandomInt(0, 9));
            }

            nickName += digitString;
        }

        thisBot.Info.Nickname = nickName;
    } else {
        let firstName;
        if (isDefined(dbgBotSettings.names, 'forcedFirstName')) {
            firstName = dbgBotSettings.names.forcedFirstName;
        } else {
            firstName = getRandomFromArray(dbNode.botNames[nameSet].firstNames);
        }

        let lastName;
        if (isDefined(dbgBotSettings.names, 'forcedLastName')) {
            lastName = dbgBotSettings.names.forcedLastName;
        } else {
            lastName = getRandomFromArray(dbNode.botNames[nameSet].lastNames);
        }

        thisBot.Info.Nickname = `${firstName} ${lastName}`;
    }
    debugOut(functionDebug, `Bot named: ${thisBot.Info.Nickname}`, 2);

    // Bot appearance
    if (dbgBotSettings.appearance.useSide) { // If 'use all items available to this side' setting is true
        // Head
        let botHeads = [...dbNode.customization[thisBot.Info.Side.toLowerCase()].head]; // Clone array
        const botHeadExcludes = dbgBotSettings.appearance.head;

        for (const thisExclusion of botHeadExcludes) {
            const exclusionIndex = botHeads.indexOf(thisExclusion);
            if (exclusionIndex >= 0) { // If this excluded item is in the heads array then the index will be positive
                //debugOut(functionDebug, `Excluded head removed: ${thisExclusion}`);
                botHeads.splice(exclusionIndex, 1) // Remove excluded item
            }
        }

        thisBot.Customization.Head = getRandomFromArray(botHeads); // Pick a random head out of the remaining heads
        debugOut(functionDebug, `Bot dynamic head: ${thisBot.Customization.Head}`, 2);

        // Voice
        let botVoices = [...dbNode.customization[thisBot.Info.Side.toLowerCase()].voice];
        const botVoiceExcludes = dbgBotSettings.appearance.voice;

        for (const thisExclusion of botVoiceExcludes) {
            const exclusionIndex = botVoices.indexOf(thisExclusion);
            if (exclusionIndex >= 0) {
                //debugOut(functionDebug, `Excluded voice removed: ${thisExclusion}`);
                botVoices.splice(exclusionIndex, 1);
            }
        }

        thisBot.Info.Voice = getRandomFromArray(botVoices);
        debugOut(functionDebug, `Bot dynamic voice: ${thisBot.Info.Voice}`, 2);

        // Upper torso and hands
        let botTorsos = utility.wipeDepend(dbNode.customization[thisBot.Info.Side.toLowerCase()].torso);
        const botTorsoExcludes = dbgBotSettings.appearance.torso;

        for (const thisExclusion of botTorsoExcludes) {
            if (isDefined(botTorsos, thisExclusion)) {
                delete botTorsos[thisExclusion];
            }
        }

        const botRandTorso = getRandomFromArray(Object.keys(botTorsos));
        thisBot.Customization.Body = dbNode.customization[thisBot.Info.Side.toLowerCase()].torso[botRandTorso].body;

        thisBot.Customization.Hands = dbNode.customization[thisBot.Info.Side.toLowerCase()].torso[botRandTorso].hands;
        debugOut(functionDebug, `Bot dynamic torso: ${botRandTorso}   body: ${thisBot.Customization.Body}   hands: ${thisBot.Customization.Hands}`, 2);

        // Legs and feet
        let botLegs = utility.wipeDepend(dbNode.customization[thisBot.Info.Side.toLowerCase()].legs);
        const botLegExcludes = dbgBotSettings.appearance.legs;

        for (const thisExclusion of botLegExcludes) {
            if (isDefined(botLegs, thisExclusion)) {
                delete botLegs[thisExclusion];
            }
        }

        const botRandLegs = getRandomFromArray(Object.keys(botLegs));
        thisBot.Customization.Feet = dbNode.customization[thisBot.Info.Side.toLowerCase()].legs[botRandLegs];
        debugOut(functionDebug, `Bot dynamic legs: ${botRandLegs}   feet: ${thisBot.Customization.Feet}`, 2);
    } else {
        thisBot.Customization.Head = getRandomFromArray(dbgBotSettings.appearance.head); // Pick a random head out of the user defined array
        debugOut(functionDebug, `Bot static head: ${thisBot.Customization.Head}`, 2);

        thisBot.Info.Voice = getRandomFromArray(dbgBotSettings.appearance.voice);
        debugOut(functionDebug, `Bot static voice: ${thisBot.Info.Voice}`, 2);

        if (isDefined(dbgBotSettings, 'appearance.outfits')) {
            const botRandOutfit = getRandomFromArray(dbgBotSettings.appearance.outfits); // Choose a random torso:legs outfit from the array
            const botRandTorso = Object.keys(botRandOutfit)[0];
            const botRandLegs = botRandOutfit[botRandTorso];

            thisBot.Customization.Body = custDB[botRandTorso]._props.Body;
            thisBot.Customization.Hands = custDB[botRandTorso]._props.Hands;
            thisBot.Customization.Feet = custDB[botRandLegs]._props.Feet;

            debugOut(functionDebug, `Bot outfit torso: ${botRandTorso}   body: ${thisBot.Customization.Body}   hands: ${thisBot.Customization.Hands}`, 2);
            debugOut(functionDebug, `Bot outfit legs: ${botRandLegs}   feet: ${thisBot.Customization.Feet}`, 2);
        } else {
            const botRandTorso = getRandomFromArray(dbgBotSettings.appearance.torso);
            if (isDefined(dbgBotSettings, 'appearance.body')) {
                thisBot.Customization.Body = getRandomFromArray(dbgBotSettings.appearance.body); // If body is defined in bot settings
            } else {
                thisBot.Customization.Body = custDB[botRandTorso]._props.Body; // Otherwise assign body as defined in the torso item
            }

            if (isDefined(dbgBotSettings, 'appearance.hands')) {
                thisBot.Customization.Hands = getRandomFromArray(dbgBotSettings.appearance.hands); // If hands are defined in bot settings
            } else {
                thisBot.Customization.Hands = custDB[botRandTorso]._props.Hands; // Otherwise assign hands as defined in the torso item
            }
            debugOut(functionDebug, `Bot static torso: ${botRandTorso}   body: ${thisBot.Customization.Body}   hands: ${thisBot.Customization.Hands}`, 2);

            const botRandLegs = getRandomFromArray(dbgBotSettings.appearance.legs);
            if (isDefined(dbgBotSettings, 'appearance.feet')) {
                thisBot.Customization.Feet = getRandomFromArray(dbgBotSettings.appearance.feet); // If feet are defined in bot settings
            } else {
                thisBot.Customization.Feet = custDB[botRandLegs]._props.Feet; // Otherwise assign feet as defined in the legs item
            }
            debugOut(functionDebug, `Bot static legs: ${botRandLegs}   feet: ${thisBot.Customization.Feet}`, 2);
        }
    }

    // Bot inventory
    let botInventory = utility.wipeDepend(newInventory()); // Generate an empty enventory
    let botInventoryLevel;
    if (thisBot.Info.Level <= 10) {
        botInventoryLevel = 'level_1_10';
    } else if (thisBot.Info.Level <= 20) {
        botInventoryLevel = 'level_11_20';
    } else if (thisBot.Info.Level <= 30) {
        botInventoryLevel = 'level_21_30';
    } else if (thisBot.Info.Level <= 40) {
        botInventoryLevel = 'level_31_40';
    } else if (thisBot.Info.Level <= 50) {
        botInventoryLevel = 'level_41_50';
    } else if (thisBot.Info.Level <= 60) {
        botInventoryLevel = 'level_51_60';
    } else {
        botInventoryLevel = 'level_61_70';
    }
    debugOut(functionDebug, `Bot inventory level: ${botInventoryLevel}`, 2);

    // Quest helper feature
    let questHelperObj = (botRole == 'sniperscav') ? {} : questHelperReadPMC(pmcData, isPlayerBot); // Give empty object if sniper scav - no sense spawning quest items on scavs that can't always be looted

    // Bot skills
    newBotSkills(thisBot.Skills, botRole, dbgBotSettings, botInventoryLevel);

    // Bot inventory - Helmet
    newEquipInSlot(botInventory, 'helmet', 'Headwear', botRole, dbgBotSettings, botInventoryLevel, questHelperObj);

    // Bot inventory - Headset
    newEquipInSlot(botInventory, 'headset', 'Earpiece', botRole, dbgBotSettings, botInventoryLevel, questHelperObj);

    // Bot inventory - Facemask
    newEquipInSlot(botInventory, 'faceMask', 'FaceCover', botRole, dbgBotSettings, botInventoryLevel, questHelperObj);

    // Bot inventory - Eyewear
    newEquipInSlot(botInventory, 'eyeWear', 'Eyewear', botRole, dbgBotSettings, botInventoryLevel, questHelperObj);

    // Bot inventory - Arm band
    newEquipInSlot(botInventory, 'armBand', 'ArmBand', botRole, dbgBotSettings, botInventoryLevel, questHelperObj);

    // Bot inventory - Backpack
    newEquipInSlot(botInventory, 'backPack', 'Backpack', botRole, dbgBotSettings, botInventoryLevel, questHelperObj);

    // Bot inventory - Chest rig
    newEquipInSlot(botInventory, 'chestRig', 'TacticalVest', botRole, dbgBotSettings, botInventoryLevel, questHelperObj);

    // Bot inventory - Armor
    newEquipInSlot(botInventory, 'chestArmor', 'ArmorVest', botRole, dbgBotSettings, botInventoryLevel, questHelperObj);

    // Bot inventory - Melee
    newEquipInSlot(botInventory, 'melee', 'Scabbard', botRole, dbgBotSettings, botInventoryLevel, questHelperObj);

    // Bot inventory - Pockets
    botInventory.items.push(utility.wipeDepend(newItem(dbgBotSettings[botInventoryLevel].inventory.pockets, botInventory.equipment, 'Pockets')));

    // Bot inventory - Secure Container
    if (!isPlayerBot) {
        botInventory.items.push(utility.wipeDepend(newItem('5c0a794586f77461c458f892', botInventory.equipment, 'SecuredContainer'))); // Add boss container to bots for loose ammo storage
    }

    // Bot inventory - Weapons
    if (randomByPercent(dbgBotSettings[botInventoryLevel].weapons.chanceForPrimary)) { // Roll to determine whether this bot gets a primary weapon
        newWeaponInSlot(botInventory, 'FirstPrimaryWeapon', botRole, dbgBotSettings, botInventoryLevel, questHelperObj); // Generate first primary weapon

        if (randomByPercent(dbgBotSettings[botInventoryLevel].weapons.chanceForSecondary)) { // Roll to detemine whether this bot also gets a second primary weapon
            newWeaponInSlot(botInventory, 'SecondPrimaryWeapon', botRole, dbgBotSettings, botInventoryLevel, questHelperObj); // Generate second primary weapon
        }

        if (randomByPercent(dbgBotSettings[botInventoryLevel].weapons.chanceForPistol)) { // Roll to detemine whether this bot also gets a pistol
            newWeaponInSlot(botInventory, 'Holster', botRole, dbgBotSettings, botInventoryLevel, questHelperObj); // Generate a pistol
        }
    } else { // If bot fails primary roll, it must get a pistol
        debugOut(functionDebug, `Bot failed roll for FirstPrimaryWeapon. Role: ${botRole}   inventory: ${botInventoryLevel}`, 2);
        newWeaponInSlot(botInventory, 'Holster', botRole, dbgBotSettings, botInventoryLevel, questHelperObj); // Generate a pistol
    }

    // Bot inventory - Magazines & ammo
    newMagsAndAmmo(botInventory, botRole, dbgBotSettings, botInventoryLevel, questHelperObj, isPlayerBot); // Add appropriate magazines with ammo to this bot's inventory

    // Bot inventory - Grenades
    newGrenades(botInventory, botRole, dbgBotSettings, botInventoryLevel, questHelperObj); // Add grenades to this bot's inventory

    // Bot inventory - Healing items
    newHealingItems(botInventory, botRole, dbgBotSettings, botInventoryLevel, questHelperObj); // Add healing items to this bot's inventory

    // Bot inventory - Specific loot, Money, Food and Drink, Random loot
    newRandomLoot(botInventory, botRole, dbgBotSettings, botInventoryLevel, questHelperObj); // Add random loot to this bot's inventory

    const questHelperArray = Object.keys(questHelperObj);
    if (questHelperArray.length > 0) { // If quest helper is enabled
        for (const thisItemObj of botInventory.items) {
            if (questHelperArray.includes(thisItemObj._tpl) && isDefined(thisItemObj, 'upd.SpawnedInSession') && thisItemObj.upd.SpawnedInSession) { // If this item is one of the items spawned by questHelper

                if (isDefined(thisItemObj, 'upd.StackObjectsCount')) {
                    debugOut(functionDebug, `questHelper item spawned: ${thisItemObj._tpl} -> ${localeDB.templates[thisItemObj._tpl].Name} x${thisItemObj.upd.StackObjectsCount}`, 3);
                } else {
                    debugOut(functionDebug, `questHelper item spawned: ${thisItemObj._tpl} -> ${localeDB.templates[thisItemObj._tpl].Name}`, 3);
                }

                dbNode.questHelper[pmcData.aid].items[thisItemObj._tpl].spawnedItems.push(thisItemObj._id); // Add the ID of this item to the array of spawnedItems for this tpl
            }
        }

        //fs.writeFileSync(aeNode.constants.modDir + '/data/questHelper.json', JSON.stringify(dbNode.questHelper, null, '\t'), 'utf8'); // Save to file so progress can be maintained between sessions
    }

    thisBot.Inventory = botInventory; // Overwrite bot inventory with our generated inventory

    // Bot side & dogtag
    if (botRole == 'usec' || botRole == 'bear') {
        newDogtag(thisBot);
    } else if (botRole == 'punisher' && randomByPercent(1)) { // Give frank a 1% chance to spawn with a dogtag as an easter egg
        thisBot.Info.Side = 'Usec';
        newDogtag(thisBot);
        thisBot.Info.Side = 'Savage';
    }
    debugOut(functionDebug, `Bot generated: ${thisBot.Info.Nickname}, role: ${botRole}, lvl: ${thisBot.Info.Level}`, 1);

    thisBot = utility.generateInventoryID(thisBot); // Assign a new ID to this bot's inventory and update item parentIds accordingly

    return thisBot;
}

function generateLotsOfBots(sessionID, generateNumBots) {// Generate shit tons of bots to break the script
    logger.logWarning(`BOT TEST: Generating ${generateNumBots} random bots...`);

    let botRoles = {};
    for (const thisRole in dbNode.botSettings) { // Read roles and set counters equal to 0 so we can display total generated bots after script runs
        botRoles[thisRole] = 0;
    }

    for (let thisIteration = 1; thisIteration < generateNumBots + 1; thisIteration++) {
        const randBotRole = getRandomFromArray(Object.keys(botRoles)); // Pick a random bot role
        botRoles[randBotRole]++; // Add to counter

        generateBot(randBotRole, sessionID, false, getRandomInt(1, 70)); // Generate bot with random role and level

        if (thisIteration % 100 == 0) {
            logger.logInfo(`BOT TEST: Generated ${thisIteration} bots...`);
        }
    }

    logger.logWarning('BOT TEST: Complete');
    for (const thisRole in botRoles) {
        logger.logInfo(`BOT TEST: Generated ${thisRole} x${botRoles[thisRole]}`);
    }
}

function itemName(itemID) { // itemName returns the item's english name as a string if defined, otherwise the item's ID
    if (isDefined(localeDB.templates, `${itemID}.Name`)) { // If this item has a defined name in the locales
        return localeDB.templates[itemID].Name;
    } else {
        return itemID;
    }
}

function presetName(presetID) { // presetName returns the preset's english name as a string if defined, otherwise the preset's ID
    if (isDefined(localeDB.preset, `${presetID}.Name`) && localeDB.preset[presetID].Name != null) { // If this item has a defined name in the locales
        return localeDB.preset[presetID].Name;
    } else if (isDefined(globalsDB.ItemPresets, `${presetID}._name`)) {
        return globalsDB.ItemPresets[presetID]._name;
    } else {
        return presetID;
    }
}

function randomByPercent(percentage) { // randomByPercent returns a true or false based on a percentage that it is given. Works with negatives (always false), floats, and numbers above 100 (always true)
    return ((Math.random() * 100) < percentage); // Returns true if roll passes, false if not
}

function randomBetweenNumbers(number1, number2) { // randomBetweenNumbers returns a random float between two input numbers
    const numberMin = Math.min(number1, number2); // Find the smaller of the two numbers
    const numberMax = Math.max(number1, number2); // Find the larger of the two numbers

    return (Math.random() * (numberMax - numberMin) + numberMin);
}

function randomBotLevel(dbgBotSettings, pmcData) { // randomBotLevel returns a botLevel and botExperience based on settings
    const playerLevel = pmcData.Info.Level // Read level of PMC
    const expTable = globalsDB.config.exp.level.exp_table; // Read EXP table so we know how much exp to give a bot of whichever level

    const botMinLevel = Math.max(dbgBotSettings.experience.level_Min, 1); // Ensure we don't try to generate a bot with a level below 1
    const botMaxLevel = Math.min(dbgBotSettings.experience.level_Max, expTable.length); // Ensure that we don't generate a bot over the max level allowed by the game

    const levelsBelow = Math.max(dbSettingsNode.botMaxLevelsBelowPlayer, 0); // Read from mod settings (and ensure some chucklefuck didn't set them to negative numbers)
    const levelsAbove = Math.max(dbSettingsNode.botMaxLevelsAbovePlayer, 0);

    let botLevel = getRandomInt(playerLevel - levelsBelow, playerLevel + levelsAbove); // Randomize bot level based on settings
    if (botLevel < botMinLevel) {
        botLevel = botMinLevel; // If bot's level was below minimum allowed level, set level to minimum instead
    } else if (botLevel > botMaxLevel) {
        botLevel = botMaxLevel; // If bot's level was above maximum allowed level, set level to maximum instead
    }

    let botExperience = 0;
    for (let i = 0; i < botLevel; i++) {
        botExperience += expTable[i].exp; // Add up each experience bracket so exp matches level
    }

    if (botLevel < expTable.length - 1) { // If this bot isn't at max level
        botExperience += getRandomInt(0, expTable[botLevel].exp - 1); // Add a random amount of experience to their current level bar
    }

    return { botLevel, botExperience };
}

function newBotID(thisBot) { // newBotID generates a new AID for a bot
    const botId = utility.generateNewAccountId();
    thisBot._id = botId;
    thisBot.aid = botId;
    return;
}

function newBotHealth(thisBot, healthObj) { // newBotHealth reads health values from settings and builds a health object in the required format
    const healthRolls = {
        hydration: getRandomInt(healthObj.hydration_Min, healthObj.hydration_Max),
        energy: getRandomInt(healthObj.energy_Min, healthObj.energy_Max),
        temperature: Math.round(randomBetweenNumbers(healthObj.temperature_Min, healthObj.temperature_Max) * 10) / 10, // Round to 1 decimal place
        head: getRandomInt(healthObj.healthHead_Min, healthObj.healthHead_Max),
        chest: getRandomInt(healthObj.healthChest_Min, healthObj.healthChest_Max),
        stomach: getRandomInt(healthObj.healthStomach_Min, healthObj.healthStomach_Max),
        leftArm: getRandomInt(healthObj.healthArms_Min, healthObj.healthArms_Max),
        rightArm: getRandomInt(healthObj.healthArms_Min, healthObj.healthArms_Max),
        leftLeg: getRandomInt(healthObj.healthLegs_Min, healthObj.healthLegs_Max),
        rightLeg: getRandomInt(healthObj.healthLegs_Min, healthObj.healthLegs_Max)
    };

    thisBot.Health = {
        Hydration: {
            Current: healthRolls.hydration,
            Maximum: healthRolls.hydration
        },
        Energy: {
            Current: healthRolls.energy,
            Maximum: healthRolls.energy
        },
        Temperature: {
            Current: healthRolls.temperature,
            Maximum: healthRolls.temperature
        },
        BodyParts: {
            Head: {
                Health: {
                    Current: healthRolls.head,
                    Maximum: healthRolls.head
                }
            },
            Chest: {
                Health: {
                    Current: healthRolls.chest,
                    Maximum: healthRolls.chest
                }
            },
            Stomach: {
                Health: {
                    Current: healthRolls.stomach,
                    Maximum: healthRolls.stomach
                }
            },
            LeftArm: {
                Health: {
                    Current: healthRolls.leftArm,
                    Maximum: healthRolls.leftArm
                }
            },
            RightArm: {
                Health: {
                    Current: healthRolls.rightArm,
                    Maximum: healthRolls.rightArm
                }
            },
            LeftLeg: {
                Health: {
                    Current: healthRolls.leftLeg,
                    Maximum: healthRolls.leftLeg
                }
            },
            RightLeg: {
                Health: {
                    Current: healthRolls.rightLeg,
                    Maximum: healthRolls.rightLeg
                }
            }
        }
    };

    return;
}

function newBotSkills(botSkillsObj, botRole, dbgBotSettings, botInventoryLevel) {
    const functionDebug = { name: 'dynamicBots.newBotSkills', debugMode: 0 }; // Debug settings for this function

    botSkillsObj.Common = []; // Clear existing skills object (or create if it doesn't exist)

    for (const thisSkillName in dbgBotSettings[botInventoryLevel].skills) {
        let thisSkillObj = {
            Id: thisSkillName,
            Progress: 0,
            PointsEarnedDuringSession: 0,
            LastAccess: 0
        };

        const thisSkillString = String(dbgBotSettings[botInventoryLevel].skills[thisSkillName]);

        if (thisSkillString.includes('-')) { // This is a skill range
            const thisSkillSplit = thisSkillString.split('-');

            thisSkillObj.Progress = Math.round(randomBetweenNumbers(thisSkillSplit[0], thisSkillSplit[1]) * 100) / 100; // Round to 2 decimal places
        } else {
            thisSkillObj.Progress = Number(thisSkillString);
        }

        debugOut(functionDebug, `${botRole}: ${botInventoryLevel} -> ${thisSkillName}: ${thisSkillObj.Progress}`, 3);

        botSkillsObj.Common.push(thisSkillObj);
    }
}

function newItem(itemID, parentID, itemSlot) { // newItem generates a blank item template to be used in a bot inventory
    const newItem = {
        _id: utility.generateNewItemId(),
        _tpl: itemID,
        parentId: parentID,
        slotId: itemSlot,
    };

    return newItem;
}

function newInventory() { // newInventory generates a blank inventory template to be used on a bot
    const equipmentId = utility.generateNewItemId();
    const equipmentTpl = '55d7217a4bdc2d86028b456d';

    const stashId = utility.generateNewItemId();
    const stashTpl = '566abbc34bdc2d92178b4576';

    const questRaidItemsId = utility.generateNewItemId();
    const questRaidItemsTpl = '5963866286f7747bf429b572';

    const questStashItemsId = utility.generateNewItemId();
    const questStashItemsTpl = '5963866b86f7747bfa1c4462';

    const thisInventory = {
        items: [{
            _id: equipmentId,
            _tpl: equipmentTpl
        },
        {
            _id: stashId,
            _tpl: stashTpl
        },
        {
            _id: questRaidItemsId,
            _tpl: questRaidItemsTpl
        },
        {
            _id: questStashItemsId,
            _tpl: questStashItemsTpl
        }
        ],
        equipment: equipmentId,
        stash: stashId,
        questRaidItems: questRaidItemsId,
        questStashItems: questStashItemsId,
        fastPanel: {}
    };

    return thisInventory;
}

function newDogtag(thisBot) { // newDogtag generates a Dogtag in the correct format and adds it to the bot
    let thisDogtag = {
        _id: utility.generateNewItemId(),
        _tpl: ((thisBot.Info.Side == 'Usec') ? '59f32c3b86f77472a31742f0' : '59f32bb586f774757e1e8442'), // Use USEC template, otherwise Bear
        parentId: thisBot.Inventory.equipment,
        slotId: 'Dogtag',
        upd: {
            'Dogtag': {
                'AccountId': thisBot.aid,
                'ProfileId': thisBot._id,
                'Nickname': thisBot.Info.Nickname,
                'Side': thisBot.Info.Side,
                'Level': thisBot.Info.Level,
                'Time': (new Date().toISOString()),
                'Status': 'Killed by ',
                'KillerAccountId': 'Unknown',
                'KillerProfileId': 'Unknown',
                'KillerName': 'Unknown',
                'WeaponName': 'Unknown'
            }
        }
    };

    if (thisBot.Info.Nickname == 'Frank Castle') {
        thisDogtag.upd.Dogtag.KillerName = 'Daken';
        thisDogtag.upd.Dogtag.WeaponName = 'Muramasa Claws';
    }

    thisBot.Inventory.items.push(thisDogtag); // Add dogtag to bot inventory
    return;
}

function newEquipInSlot(botInventory, newItemType, itemSlot, botRole, dbgBotSettings, botInventoryLevel, questHelperObj) { // newEquipInSlot generates new bot equipment for a specific slot based on settings
    const functionDebug = { name: 'dynamicBots.newEquipInSlot', debugMode: 0 }; // Debug settings for this function

    let forceEquipSpawn = false;

    let equippedSlots = {}; // Generate a list of equipmentslots already occupied on this bot
    for (const thisItem of botInventory.items) {
        if (isDefined(thisItem, 'slotId')) {
            if (!isDefined(equippedSlots, thisItem.slotId)) {
                equippedSlots[thisItem.slotId] = thisItem._tpl;
            }
        }
    }

    if (newItemType == 'chestRig' && dbgBotSettings[botInventoryLevel].backPack.forceChestRig) { // If this item is a chestrig and the backPack -> forceChestRig setting is true
        if (!isDefined(equippedSlots, 'Backpack')) { // If bot has no backpack equipped
            debugOut(functionDebug, 'Bot has no backpack; forcing chest rig to spawn', 2);
            forceEquipSpawn = true; // If no backpack, force chest rig to spawn
        }
    }

    if (newItemType == 'chestArmor') {
        if (isDefined(equippedSlots, 'TacticalVest') && isDefined(itemDB, `${equippedSlots['TacticalVest']}._props.armorClass`)) {
            if (itemDB[equippedSlots['TacticalVest']]._props.armorClass > 0) { // If the bot has an armored chest rig then skip armor
                debugOut(functionDebug, 'Bot has armored rig; skipping armor', 2);
                return;
            }
        }
    }

    if (randomByPercent(dbgBotSettings[botInventoryLevel][newItemType].chanceToEquip) || forceEquipSpawn) { // Roll whether to equip this bot with this item
        let randNewItem;
        if (isDefined(dbgBotSettings[botInventoryLevel], `${newItemType}.forceItemBuild`) && dbgBotSettings[botInventoryLevel][newItemType].forceItemBuild.length > 0) { // If there's a forced build for this slot
            let thisNewItemObj;
            if (Array.isArray(dbgBotSettings[botInventoryLevel][newItemType].forceItemBuild[0])) {
                if (dbgBotSettings[botInventoryLevel][newItemType].forceItemBuild.length > 1) {
                    const randForceBuildIndex = getRandomInt(0, dbgBotSettings[botInventoryLevel][newItemType].forceItemBuild.length - 1); // Pick a random build by index
                    thisNewItemObj = utility.wipeDepend(dbgBotSettings[botInventoryLevel][newItemType].forceItemBuild[randForceBuildIndex]); // Copy item from random forced build index
                } else { // Only one item in forced build
                    thisNewItemObj = utility.wipeDepend(dbgBotSettings[botInventoryLevel][newItemType].forceItemBuild[0]); // Copy item from only forced build index
                }
            } else {
                thisNewItemObj = utility.wipeDepend(dbgBotSettings[botInventoryLevel][newItemType].forceItemBuild); // Copy item from forced build
            }

            let isCompatible = true;
            let parentArray = {};
            for (let thisPart of thisNewItemObj) {
                let newID = utility.generateNewItemId(); // Generate new ID for the item
                parentArray[thisPart._id] = newID; // Record original ID and new one
                thisPart._id = newID; // Set new ID for this item
            }
            for (let thisPart of thisNewItemObj) {
                if (verifyItemCompatible(botInventory, itemSlot, thisPart._tpl)) { // If item is compatible
                    if (isDefined(thisPart, 'parentId') && isDefined(parentArray, thisPart.parentId)) {
                        thisPart.parentId = parentArray[thisPart.parentId]; // Make sure the parent ID is updated
                    } else {
                        thisPart.parentId = botInventory.equipment;
                        thisPart.slotId = itemSlot;
                    }
                    if (itemDB[thisPart._tpl]._props.armorClass > 0 || newItemType == 'melee') {
                        newItemProperties(thisPart, dbgBotSettings[botInventoryLevel][newItemType], botRole, true); // Send this item off to get durability and FIR status
                    } else {
                        newItemProperties(thisPart, dbgBotSettings[botInventoryLevel][newItemType], botRole); // Send this item off to get FIR status
                    }

                    //console.info(thisPart);
                    botInventory.items.push(thisPart);
                } else {
                    isCompatible = false;
                }
            }
            if (isCompatible) { // If preset is compatible
                debugOut(functionDebug, `Equipped forced preset ${newItemType}`, 2);
            } else {
                debugOut(functionDebug, `Forced preset ${newItemType}is incompatible with this inventory. Role: ${botRole}   inventory: ${botInventoryLevel}`, 1, 'warning');
            }
        } else if (dbgBotSettings[botInventoryLevel][newItemType].forceItems.length > 0) { // If items are forced in this slot
            let forcedItemsArray = [...dbgBotSettings[botInventoryLevel][newItemType].forceItems]; // Clone array
            for (let thisForcedItemAttempt = 0; thisForcedItemAttempt < forcedItemsArray.length; thisForcedItemAttempt++) {
                randNewItem = questHelperGetRandomItem(questHelperObj, forcedItemsArray); // Use quest helper if enabled, otherwise random item out of the forced slot
                if (verifyItemCompatible(botInventory, itemSlot, randNewItem)) { // If item is compatible
                    let thisNewItem = utility.wipeDepend(newItem(randNewItem, botInventory.equipment, itemSlot)); // Generate the item
                    debugOut(functionDebug, `Selected ${newItemType}: ${randNewItem} => ${itemName(randNewItem)}`, 2);
                    if (isDefined(itemDB, `${randNewItem}._props`)) {
                        if ((isDefined(itemDB[randNewItem]._props, 'armorClass') && itemDB[randNewItem]._props.armorClass > 0) || newItemType == 'melee') {
                            newItemProperties(thisNewItem, dbgBotSettings[botInventoryLevel][newItemType], botRole, true); // Send this item off to get durability and FIR status

                            if (isDefined(dbgBotSettings[botInventoryLevel], `${newItemType}.modBudget_Min`) && isDefined(dbgBotSettings[botInventoryLevel], `${newItemType}.modBudget_Max`) && (itemDB[randNewItem]._props.Slots.length > 0)) {
                                let modBudget = randomBetweenNumbers(dbgBotSettings[botInventoryLevel][newItemType].modBudget_Min, dbgBotSettings[botInventoryLevel][newItemType].modBudget_Max); // Get random mod budget from settings
                                debugOut(functionDebug, `${newItemType} mod budget: ${modBudget}`, 2);
                                let newItemObj = [thisNewItem];
                                addMods(dbgBotSettings[botInventoryLevel][newItemType], newItemObj, botRole, modBudget);
                                //console.info(newItemObj);
                                botInventory.items.push(...newItemObj);
                                break; // Exit the for loop
                            } else {
                                //console.info(thisNewItem);
                                botInventory.items.push(thisNewItem);
                                break; // Exit the for loop
                            }
                        } else {
                            newItemProperties(thisNewItem, dbgBotSettings[botInventoryLevel][newItemType], botRole); // Send this item off to get FIR status
                            //console.info(thisNewItem);
                            botInventory.items.push(thisNewItem);
                            break; // Exit the for loop
                        }
                    } else {
                        debugOut(functionDebug, `Forced ${newItemType} ${randNewItem} does not exist. Role: ${botRole}   inventory: ${botInventoryLevel}`, 0, 'error');
                        forcedItemsArray.splice(forcedItemsArray.indexOf(randNewItem), 1); // Remove from array
                        continue;
                    }
                } else {
                    debugOut(functionDebug, `Forced ${newItemType} ${randNewItem} is incompatible with this inventory. Role: ${botRole}   inventory: ${botInventoryLevel}`, 1, 'warning');
                    forcedItemsArray.splice(forcedItemsArray.indexOf(randNewItem), 1); // Remove from array
                    continue;
                }
            }
            if (forcedItemsArray.length == 0) {
                debugOut(functionDebug, `No forced ${newItemType}s were compatible with this inventory. Role: ${botRole}   inventory: ${botInventoryLevel}`, 1, 'warning');
            }
        } else {
            let itemArray = utility.wipeDepend(dbNode.itemArray[newItemType]); // Copy item array from db

            if (dbgBotSettings[botInventoryLevel][newItemType].forbidItems.length > 0) { // If there are forbidden items
                for (let thisItemIndex = (Object.keys(itemArray).length - 1); thisItemIndex >= 0; thisItemIndex--) { // Iterate backwards since we might be deleting items
                    const thisItem = Object.keys(itemArray)[thisItemIndex];
                    if (dbgBotSettings[botInventoryLevel][newItemType].forbidItems.includes(thisItem)) { // If this item is in the forbidden items list
                        debugOut(functionDebug, `Forbidden ${newItemType}: ${thisItem}`, 2);
                        delete itemArray[thisItem]; // Remove forbidden items from array
                    }
                }
            }

            if (Object.keys(itemArray).length > 0) { // If there are still items in the array after removing forbidden items
                for (let thisItemIndex = (Object.keys(itemArray).length - 1); thisItemIndex >= 0; thisItemIndex--) { // Iterate backwards since we might be deleting items
                    const thisItem = Object.keys(itemArray)[thisItemIndex];
                    if (itemArray[thisItem] < dbgBotSettings[botInventoryLevel][newItemType].value_Min || itemArray[thisItem] > dbgBotSettings[botInventoryLevel][newItemType].value_Max) { // If this item's value is less than the allowed minimum or greater than the allowed maximum
                        debugOut(functionDebug, `${newItemType} wrong price: ${thisItem}   ${dbgBotSettings[botInventoryLevel][newItemType].value_Min}   ${itemArray[thisItem]}   ${dbgBotSettings[botInventoryLevel][newItemType].value_Max}`, 3);
                        delete itemArray[thisItem]; // Remove from array
                    }
                }
                if (Object.keys(itemArray).length > 0) { // If there are still items in the array after removing cheap/expensive items
                    let itemIsArmored;
                    if (newItemType == 'chestArmor') {
                        itemIsArmored = true;

                    } else if (isDefined(dbgBotSettings[botInventoryLevel], `${newItemType}.chanceForArmored`)) {
                        debugOut(functionDebug, `${newItemType} rolling for armor`, 3);
                        itemIsArmored = randomByPercent(dbgBotSettings[botInventoryLevel][newItemType].chanceForArmored); // Roll chanceForArmored to get a true/false based on the setting
                    } else { // No chanceForArmored setting for this item
                        debugOut(functionDebug, `${newItemType} can't be armored`, 3);
                        itemIsArmored = false;
                    }

                    if (itemIsArmored) { // Equip an armored item
                        let minArmor = Math.min(dbgBotSettings[botInventoryLevel][newItemType].armorClass_Min, dbgBotSettings[botInventoryLevel][newItemType].armorClass_Max); // Make sure min is actually the smaller number
                        minArmor = Math.max(dbgBotSettings[botInventoryLevel][newItemType].armorClass_Min, 1); // Make sure it's at least 1

                        let maxArmor = Math.max(dbgBotSettings[botInventoryLevel][newItemType].armorClass_Min, dbgBotSettings[botInventoryLevel][newItemType].armorClass_Max); // Make sure max is the larger number
                        maxArmor = Math.max(dbgBotSettings[botInventoryLevel][newItemType].armorClass_Max, 1);

                        for (let thisItemIndex = (Object.keys(itemArray).length - 1); thisItemIndex >= 0; thisItemIndex--) { // Iterate backwards since we might be deleting items
                            const thisItem = Object.keys(itemArray)[thisItemIndex];
                            if (itemDB[thisItem]._props.armorClass < minArmor || itemDB[thisItem]._props.armorClass > maxArmor) { // If this item's armor is less than minimum or greater than maximum
                                debugOut(functionDebug, `${newItemType} armor out of bounds: ${thisItem}   ${minArmor}   ${itemDB[thisItem]._props.armorClass}   ${maxArmor}`, 3);
                                delete itemArray[thisItem]; // Remove from array
                            }
                        }
                        if (Object.keys(itemArray).length > 0) { // If there are still items in the array after removing items with armor that is too high/too low
                            debugOut(functionDebug, `Selecting armored ${newItemType} from  ${Object.keys(itemArray).length} candidates`, 2);
                            for (let thisArmoredItemAttempt = 0; thisArmoredItemAttempt < Object.keys(itemArray).length; thisArmoredItemAttempt++) {
                                randNewItem = questHelperGetRandomItem(questHelperObj, Object.keys(itemArray)); // Use quest helper if enabled, otherwise random

                                if (verifyItemCompatible(botInventory, itemSlot, randNewItem)) { // If item is compatible
                                    debugOut(functionDebug, `Selected ${newItemType}: ${randNewItem} => ${itemName(randNewItem)}`, 2);
                                    let thisNewItem = utility.wipeDepend(newItem(randNewItem, botInventory.equipment, itemSlot)); // Generate the item
                                    newItemProperties(thisNewItem, dbgBotSettings[botInventoryLevel][newItemType], botRole, true);

                                    if (isDefined(dbgBotSettings[botInventoryLevel], `${newItemType}.modBudget_Min`) && isDefined(dbgBotSettings[botInventoryLevel], `${newItemType}.modBudget_Max`) && (itemDB[randNewItem]._props.Slots.length > 0)) {
                                        let modBudget = randomBetweenNumbers(dbgBotSettings[botInventoryLevel][newItemType].modBudget_Min, dbgBotSettings[botInventoryLevel][newItemType].modBudget_Max); // Get random mod budget from settings
                                        debugOut(functionDebug, `Helmet mod budget: ${modBudget}`, 2);
                                        let newItemObj = [thisNewItem];
                                        addMods(dbgBotSettings[botInventoryLevel][newItemType], newItemObj, botRole, modBudget);
                                        //console.info(newItemObj);
                                        botInventory.items.push(...newItemObj);
                                        break;
                                    } else {
                                        //console.info(thisNewItem);
                                        botInventory.items.push(thisNewItem);
                                        break;
                                    }
                                } else {
                                    debugOut(functionDebug, `Selected ${newItemType} ${randNewItem} (${itemName(randNewItem)}) is incompatible with this inventory. Role: ${botRole}   inventory: ${botInventoryLevel}`, 3);
                                    delete itemArray[randNewItem]; // Remove from array
                                }
                                if (Object.keys(itemArray).length == 0) {
                                    debugOut(functionDebug, `No ${newItemType}s were compatible with this inventory. Role: ${botRole}   inventory: ${botInventoryLevel}`, 2, 'warning');
                                    break;
                                }
                            }
                        } else {
                            debugOut(functionDebug, `All armored ${newItemType} are outside of allowable values. Role: ${botRole}   inventory: ${botInventoryLevel}`, 1, 'warning');
                        }
                    } else { // Equip an unarmored item
                        for (let thisItemIndex = (Object.keys(itemArray).length - 1); thisItemIndex >= 0; thisItemIndex--) { // Iterate backwards since we might be deleting items
                            const thisItem = Object.keys(itemArray)[thisItemIndex];
                            if (itemDB[thisItem]._props.armorClass > 0) { // If this is an armored item
                                debugOut(functionDebug, `${newItemType} too armored: ${thisItem}   ${itemDB[thisItem]._props.armorClass}`, 3);
                                delete itemArray[thisItem]; // Remove from array
                            }
                            if (itemSlot == 'FaceCover') {
                                if (dbNode.itemArray.facemaskClipsWithHelmet.includes(thisItem) && isDefined(equippedSlots, 'Headwear')) { // If there is headwear equipped
                                    if (itemDB[equippedSlots['Headwear']]._props.armorClass == 0) { // And if the headwear is unarmored
                                        debugOut(functionDebug, `${newItemType} incompatible due to headwear: ${thisItem}`, 3);
                                        delete itemArray[thisItem]; // Remove from array
                                    }
                                }
                            }
                        }
                        if (Object.keys(itemArray).length > 0) {
                            debugOut(functionDebug, `Selecting ${newItemType} from ${Object.keys(itemArray).length} candidates`, 2);
                            for (let thisEquipItemAttempt = 0; thisEquipItemAttempt < Object.keys(itemArray).length; thisEquipItemAttempt++) {
                                randNewItem = questHelperGetRandomItem(questHelperObj, Object.keys(itemArray)); // Use quest helper if enabled, otherwise random

                                if (verifyItemCompatible(botInventory, itemSlot, randNewItem)) { // If item is compatible
                                    let thisNewItem = utility.wipeDepend(newItem(randNewItem, botInventory.equipment, itemSlot));

                                    if (newItemType == 'melee') {
                                        newItemProperties(thisNewItem, dbgBotSettings[botInventoryLevel][newItemType], botRole, true);
                                    } else {
                                        newItemProperties(thisNewItem, dbgBotSettings[botInventoryLevel][newItemType], botRole);
                                    }

                                    debugOut(functionDebug, `Selected ${newItemType}: ${randNewItem} => ${itemName(randNewItem)}`, 2);
                                    //console.info(thisNewItem);
                                    botInventory.items.push(thisNewItem);
                                    break;
                                } else {
                                    debugOut(functionDebug, `Selected ${newItemType} ${randNewItem} (${itemName(randNewItem)}) is incompatible with this inventory. Role: ${botRole}   inventory: ${botInventoryLevel}`, 3);
                                    delete itemArray[randNewItem]; // Remove from array
                                }
                                if (Object.keys(itemArray).length == 0) {
                                    debugOut(functionDebug, `No ${newItemType}s were compatible with this inventory. Role: ${botRole}   inventory: ${botInventoryLevel}`, 2, 'warning');
                                    break;
                                }
                            }
                        } else {
                            debugOut(functionDebug, `All ${newItemType}s are outside of allowable values. Role: ${botRole}   inventory: ${botInventoryLevel}`, 1, 'warning');
                        }
                    }
                } else {
                    debugOut(functionDebug, `All ${newItemType}s are outside of allowable values. Role: ${botRole}   inventory: ${botInventoryLevel}`, 1, 'warning');
                }
            } else {
                debugOut(functionDebug, `All ${newItemType}s are forbidden. Role: ${botRole}   inventory: ${botInventoryLevel}`, 1, 'warning');
            }
        }
    } else {
        debugOut(functionDebug, `Bot failed roll for item: ${newItemType}. Role: ${botRole}   inventory: ${botInventoryLevel}`, 2);
    }
    return;
}

function verifyItemCompatible(botInventory, newItemSlot, newItemID) { // verifyItemCompatible checks to make sure that an item is compatible with the current inventory of the bot
    const slotBlockTypes = [
        'Earpiece',
        'Eyewear',
        'Headwear',
        'FaceCover'
    ]

    if ((newItemSlot == 'Earpiece') && (itemDB[newItemID]._props.BlocksEarpiece)) { // This is a helmet mounted headset
        return false;
    }
    for (const thisItem of botInventory.items) {
        if (isDefined(thisItem, 'slotId')) { // If this item has a slotId
            if (slotBlockTypes.includes(thisItem.slotId)) { // If the existing item's slotId is one of the slots that can be blocked
                if (isDefined(itemDB, `${newItemID}._props.Blocks${newItemSlot}`)) { // If the new item has this Blocks___ property; ie 'BlocksEarpiece': true
                    if (itemDB[newItemID]._props[`Blocks${newItemSlot}`]) { // And if this Blocks___ property is true
                        return false; // Then this new item is incompatible
                    }
                }
            }
        }

        if (slotBlockTypes.includes(newItemSlot)) { // If the new item's slotId is one of the slots that can be blocked
            if (isDefined(itemDB, `${thisItem._tpl}._props.Blocks${newItemSlot}`)) { // If the existing inventory item has a Blocks___ property that matches the new item
                if (itemDB[thisItem._tpl]._props[`Blocks${newItemSlot}`]) { //  And if the Blocks___ property is true
                    return false; // Then this new item is incompatible
                }
            }
        }

        if (itemDB[thisItem._tpl]._props.ConflictingItems.includes(newItemID)) { // If the existing inventory item includes the new item in its ConflictingItems array
            return false; // Then this new item is incompatible
        }
    }

    return true; // If we make it this far without returning false, the item is compatible with the bot's inventory
}

function addItemsToInventory(botInventory, itemArray) { // addItemsToInventory adds an array of items to a bot's inventory
    for (const thisItem of itemArray) {
        botInventory.items.push(thisItem); // Add all of the items in this preset to the bot's inventory
    }
}

function addItemsToContainers(botInventory, itemsToAdd, containerPreference, discardUnplaceableItems = false) { // addItemsToContainers adds an array of items to containers in a bot's inventory (chest rig, pockets, backpacks)
    const functionDebug = { name: 'dynamicBots.addItemsToContainers', debugMode: 0 }; // Debug settings for this function

    debugOut(functionDebug, '------BEGIN------', 2, 'warning');
    let containerObjs = [];
    for (const thisSlot of containerPreference) { // Iterate through containers in order so we can add their objects to containerObjs
        for (const thisItem of botInventory.items) { // Find the container
            if (typeof thisItem.slotId != 'undefined') {
                if (thisItem.slotId == thisSlot) { // If the slot is found
                    containerObjs.push(thisItem); // Add it to the array
                    break;
                }
            }
        }
    }

    if (containerObjs.length > 0) {
        let containerMaps = {}; // Make maps of each container
        for (const thisContainer of containerObjs) {
            debugOut(functionDebug, `Container: ${thisContainer._id}   ${thisContainer._tpl}`, 2, 'warning');

            containerMaps[thisContainer._id] = {}; // Declare this container
            if (isDefined(itemDB, `${thisContainer._tpl}._props.Grids`)) {
                for (const thisGrid of itemDB[thisContainer._tpl]._props.Grids) {
                    containerMaps[thisContainer._id][thisGrid._name] = {}; // Declare each grid by name

                    if (isDefined(thisGrid, '_props.cellsH') && isDefined(thisGrid, '_props.cellsV')) {
                        containerMaps[thisContainer._id][thisGrid._name].height = thisGrid._props.cellsV;
                        containerMaps[thisContainer._id][thisGrid._name].width = thisGrid._props.cellsH;

                        for (let thisRow = 0; thisRow < thisGrid._props.cellsV; thisRow++) {
                            containerMaps[thisContainer._id][thisGrid._name][thisRow] = {}; // Define this row
                            for (let thisColumn = 0; thisColumn < thisGrid._props.cellsH; thisColumn++) {
                                containerMaps[thisContainer._id][thisGrid._name][thisRow][thisColumn] = null; // Set this column to null
                            }
                        }
                    } else {
                        debugOut(functionDebug, `Container grid size undefined: ${thisContainer._tpl}`, 0, 'error');
                        return [];
                    }
                }
            } else {
                debugOut(functionDebug, `Container grids undefined: ${thisContainer._tpl}`, 0, 'error');
                return [];
            }
        }

        for (const thisItem of botInventory.items) { // Iterate through bot's inventory items to figure out where they are in containers
            if (isDefined(thisItem, 'parentId') && isDefined(thisItem, 'slotId') && isDefined(containerMaps, `${thisItem.parentId}.${thisItem.slotId}`)) { // If the container has the slot described by the item
                if (isDefined(thisItem, 'location.x') && isDefined(thisItem, 'location.y') && isDefined(thisItem, 'location.r')) { // If this item has location info
                    if (isDefined(containerMaps, `${thisItem.parentId}.${thisItem.slotId}.${thisItem.location.y}.${thisItem.location.x}`)) { // If this item's "anchor" square is part of this container (the x y defined location)
                        let thisItemHeight;
                        let thisItemWidth;

                        if (thisItem.location.r == 'Horizontal') {
                            thisItemWidth = itemDB[thisItem._tpl]._props.Width
                            thisItemHeight = itemDB[thisItem._tpl]._props.Height;
                        } else {
                            thisItemWidth = itemDB[thisItem._tpl]._props.Height
                            thisItemHeight = itemDB[thisItem._tpl]._props.Width;
                        }

                        for (let thisRow = thisItem.location.y; thisRow < (thisItem.location.y + thisItemHeight); thisRow++) { // Iterate item height in relation to inventory squares
                            for (let thisColumn = thisItem.location.x; thisColumn < (thisItem.location.x + thisItemWidth); thisColumn++) { // Iterate item width in relation to inventory squares
                                if (isDefined(containerMaps, `${thisItem.parentId}.${thisItem.slotId}.${thisRow}.${thisColumn}`)) { // If the grid square this item occupies exists in the container
                                    debugOut(functionDebug, `Read inventory: Item ${thisItem._id} (${thisItemHeight}x${thisItemWidth}) at ${thisItem.parentId} G${thisItem.slotId} R${thisRow} C${thisColumn}`, 2);
                                    containerMaps[thisItem.parentId][thisItem.slotId][thisRow][thisColumn] = thisItem._id; // Mark this grid square as occupied by this item
                                } else {
                                    debugOut(functionDebug, `Inventory item occupies invalid slot: _id: ${thisItem._id} _tpl: ${thisItem._tpl} parentId: ${thisItem.parentId} slotId: ${thisItem.slotId} y: ${thisRow} x: ${thisColumn}`, 0, 'error');
                                    return [];
                                }
                            }
                        }
                    }
                } else {
                    debugOut(functionDebug, `Inventory item missing location info: _id: ${thisItem._id} _tpl: ${thisItem._tpl} parentId: ${thisItem.parentId} slotId: ${thisItem.slotId}`, 0, 'error');
                    return [];
                }
            }
        }

        //debugOut(functionDebug, 'itemsToAdd:');
        //console.info(itemsToAdd);

        debugOut(functionDebug, '------ADDITEMS------', 2, 'warning');

        let itemDiscardArray = []; // If discardUnplaceableItems == true then this will contain the _ids of items to discard
        addItems: // Label this for loop so we can continue when an item is placed
        for (const thisItem of itemsToAdd) {
            if (isDefined(itemDB, `${thisItem._tpl}._props.Height`) && isDefined(itemDB, `${thisItem._tpl}._props.Width`)) {
                const thisItemHeight = itemDB[thisItem._tpl]._props.Height;
                const thisItemWidth = itemDB[thisItem._tpl]._props.Width;

                let placedItem = false;
                for (const thisContainer in containerMaps) { // Iterate through containers to find a place to put this item
                    for (const thisGrid in containerMaps[thisContainer]) {
                        if (containerMaps[thisContainer][thisGrid].height == thisItemHeight && containerMaps[thisContainer][thisGrid].width == thisItemWidth) { // Check slots that are the exact size we need, horizontally
                            if (containerMaps[thisContainer][thisGrid][0][0] != null) {
                                debugOut(functionDebug, `Exact horizontal: Occupied ${thisContainer} G${thisGrid} R${0} C${0}`, 2);
                                continue;
                            }
                            // If this loop hasn't been continued then this slot is empty. Place the item here
                            debugOut(functionDebug, `Exact horizontal: Placing ${thisItem._id} (${thisItemHeight}x${thisItemWidth}) at ${thisContainer} G${thisGrid} R${0} C${0}`, 2);

                            thisItem.parentId = thisContainer;
                            thisItem.slotId = thisGrid;
                            thisItem.location = { // Define location array
                                'x': 0,
                                'y': 0,
                                'r': 'Horizontal'
                            };

                            for (let thisMarkedRow = 0; thisMarkedRow < thisItemHeight; thisMarkedRow++) {
                                for (let thisMarkedColumn = 0; thisMarkedColumn < thisItemWidth; thisMarkedColumn++) {
                                    containerMaps[thisContainer][thisGrid][thisMarkedRow][thisMarkedColumn] = thisItem._id; // Mark these slots as occupied by this item
                                }
                            }

                            placedItem = true;
                            continue addItems;
                        }
                    }

                    if (!placedItem) { // If the item hasn't been placed, try an exact vertical fit
                        for (const thisGrid in containerMaps[thisContainer]) {
                            if (containerMaps[thisContainer][thisGrid].width == thisItemHeight && containerMaps[thisContainer][thisGrid].height == thisItemWidth) { // Check slots that are the exact size we need, vertically
                                if (containerMaps[thisContainer][thisGrid][0][0] != null) {
                                    debugOut(functionDebug, `Exact vertical: Occupied ${thisContainer} G${thisGrid} R${0} C${0}`, 2);
                                    continue;
                                }
                                debugOut(functionDebug, `Exact vertical: Placing ${thisItem._id} (${thisItemHeight}x${thisItemWidth}) at ${thisContainer} G${thisGrid} R${0} C${0}`, 2);

                                thisItem.parentId = thisContainer;
                                thisItem.slotId = thisGrid;
                                thisItem.location = { // Define location array
                                    'x': 0,
                                    'y': 0,
                                    'r': 'Vertical'
                                };

                                for (let thisMarkedRow = 0; thisMarkedRow < thisItemWidth; thisMarkedRow++) {
                                    for (let thisMarkedColumn = 0; thisMarkedColumn < thisItemHeight; thisMarkedColumn++) {
                                        containerMaps[thisContainer][thisGrid][thisMarkedRow][thisMarkedColumn] = thisItem._id; // Mark these slots as occupied by this item
                                    }
                                }

                                placedItem = true;
                                continue addItems;
                            }
                        }
                    }

                    if (!placedItem) { // If the item hasn't been placed, try fitting it horizontally in a grid that's larger than the size of this item
                        for (const thisGrid in containerMaps[thisContainer]) {
                            if (containerMaps[thisContainer][thisGrid].height >= thisItemHeight && containerMaps[thisContainer][thisGrid].width >= thisItemWidth) { // Check slots that are larger than the size we need, horizontally
                                for (let thisRow = 0; thisRow <= (containerMaps[thisContainer][thisGrid].height - thisItemHeight); thisRow++) {
                                    columnSearch: for (let thisColumn = 0; thisColumn <= (containerMaps[thisContainer][thisGrid].width - thisItemWidth); thisColumn++) {
                                        for (let thisSearchRow = thisRow; thisSearchRow < (thisRow + thisItemHeight); thisSearchRow++) { // Search the surrounding squares in the shape of this item
                                            for (let thisSearchColumn = thisColumn; thisSearchColumn < (thisColumn + thisItemWidth); thisSearchColumn++) {
                                                if (containerMaps[thisContainer][thisGrid][thisSearchRow][thisSearchColumn] != null) {
                                                    debugOut(functionDebug, `Larger horizontal: Occupied ${thisContainer} G${thisGrid} R${thisSearchRow} C${thisSearchColumn}`, 2);
                                                    continue columnSearch; // Search the next column to the right
                                                }
                                            }
                                        }
                                        debugOut(functionDebug, `Larger horizontal: Placing ${thisItem._id} (${thisItemHeight}x${thisItemWidth}) at ${thisContainer} G${thisGrid} R${thisRow} C${thisColumn}`, 2);

                                        thisItem.parentId = thisContainer;
                                        thisItem.slotId = thisGrid;
                                        thisItem.location = { // Define location array
                                            'x': thisColumn,
                                            'y': thisRow,
                                            'r': 'Horizontal'
                                        };

                                        for (let thisMarkedRow = thisRow; thisMarkedRow < (thisRow + thisItemHeight); thisMarkedRow++) {
                                            for (let thisMarkedColumn = thisColumn; thisMarkedColumn < (thisColumn + thisItemWidth); thisMarkedColumn++) {
                                                containerMaps[thisContainer][thisGrid][thisMarkedRow][thisMarkedColumn] = thisItem._id; // Mark these slots as occupied by this item
                                            }
                                        }

                                        placedItem = true;
                                        continue addItems;
                                    }
                                }
                            }
                        }
                    }

                    if (!placedItem) { // If the item hasn't been placed, try fitting it vertically in a grid that's larger than the size of this item
                        for (const thisGrid in containerMaps[thisContainer]) {
                            if (containerMaps[thisContainer][thisGrid].height >= thisItemWidth && containerMaps[thisContainer][thisGrid].width >= thisItemHeight) { // Check slots that are larger than the size we need, vertically
                                for (let thisRow = 0; thisRow <= (containerMaps[thisContainer][thisGrid].height - thisItemWidth); thisRow++) {
                                    columnSearch: for (let thisColumn = 0; thisColumn <= (containerMaps[thisContainer][thisGrid].width - thisItemHeight); thisColumn++) {
                                        for (let thisSearchRow = thisRow; thisSearchRow < (thisRow + thisItemWidth); thisSearchRow++) { // Search the surrounding squares in the shape of this item
                                            for (let thisSearchColumn = thisColumn; thisSearchColumn < (thisColumn + thisItemHeight); thisSearchColumn++) {
                                                if (containerMaps[thisContainer][thisGrid][thisSearchRow][thisSearchColumn] != null) {
                                                    debugOut(functionDebug, `Larger vertical: Occupied ${thisContainer} G${thisGrid} R${thisSearchRow} C${thisSearchColumn}`, 2);
                                                    continue columnSearch; // Search the next column to the right
                                                }
                                            }
                                        }
                                        debugOut(functionDebug, `Larger vertical: Placing ${thisItem._id} (${thisItemHeight}x${thisItemWidth}) at ${thisContainer} G${thisGrid} R${thisRow} C${thisColumn}`, 2);

                                        thisItem.parentId = thisContainer;
                                        thisItem.slotId = thisGrid;
                                        thisItem.location = { // Define location array
                                            'x': thisColumn,
                                            'y': thisRow,
                                            'r': 'Vertical'
                                        };

                                        for (let thisMarkedRow = thisRow; thisMarkedRow < (thisRow + thisItemWidth); thisMarkedRow++) {
                                            for (let thisMarkedColumn = thisColumn; thisMarkedColumn < (thisColumn + thisItemHeight); thisMarkedColumn++) {
                                                containerMaps[thisContainer][thisGrid][thisMarkedRow][thisMarkedColumn] = thisItem._id; // Mark these slots as occupied by this item
                                            }
                                        }

                                        placedItem = true;
                                        continue addItems;
                                    }
                                }
                            }
                        }
                    }
                }
                if (!placedItem) {
                    if (discardUnplaceableItems) {
                        debugOut(functionDebug, `Unable to place item ${thisItem._id} -> ${thisItem._tpl} in this bot's inventory`, 2, 'warning');
                        itemDiscardArray.push(thisItem._id);
                    } else {
                        debugOut(functionDebug, `Unable to place item ${thisItem._id} -> ${thisItem._tpl} in this bot's inventory`, 0, 'error');
                        return [];
                    }
                }
            } else {
                debugOut(functionDebug, `Item ${thisItem._tpl} does not have a defined size`, 0, 'error');
                return [];
            }
        }
        /*
        // Advanced debugging
        //debugOut(functionDebug, 'After loops:');
        //console.info(itemsToAdd);

        let unixTime = Date.now();
        //console.info(containerMaps);
        debugOut(functionDebug, `containerMaps written to file ${unixTime}`);
        fs.mkdirSync(aeNode.constants.modDir + '/debug/containerMaps', { recursive: true });
        fs.writeFileSync(`${aeNode.constants.modDir}/debug/containerMaps/${unixTime}.json`, JSON.stringify([containerObjs, containerMaps], null, '\t'), 'utf8');
        */
        debugOut(functionDebug, '------END------', 2, 'warning');
        return itemDiscardArray;
    } else {
        debugOut(functionDebug, `Unable to find containers in this bot's inventory`, 2, 'error');
        return [];
    }
}

function newWeaponInSlot(botInventory, itemSlot, botRole, dbgBotSettings, botInventoryLevel, questHelperObj) { // newWeaponInSlot generates a new weapon for a specific equipment slot based on settings and places it on a bot
    const functionDebug = { name: 'dynamicBots.newWeaponInSlot', debugMode: 0 }; // Debug settings for this function

    let weaponNode;
    let weaponType;
    if (itemSlot == 'Holster') {
        weaponNode = dbgBotSettings[botInventoryLevel].weapons.pistol;
        weaponType = 'pistol';
    } else {
        weaponNode = dbgBotSettings[botInventoryLevel].weapons.primary;
        if (weaponNode.forceItemBuild.length == 0) {
            let preferenceArray = [];

            for (const thisType in weaponNode.preference) {
                if (weaponNode.preference[thisType] > 0) {
                    for (let i = 1; i <= weaponNode.preference[thisType]; i++) {
                        preferenceArray.push(thisType); // Build an array of weapon preferences; add weapons X number of times by preference to make them more or less likely
                    }
                }
            }
            weaponType = getRandomFromArray(preferenceArray);
        }
    }

    if (weaponNode.forceItemBuild.length == 0) { // If there's no forced item build
        debugOut(functionDebug, `Weapon type: ${weaponType}. Role: ${botRole}   inventory: ${botInventoryLevel}`, 2);

        const gunGenerationAttempts = 10;

        let randNewWeapon;
        if (weaponNode.forcePresets.length > 0) { // If items are forced in this slot
            randNewWeapon = questHelperGetRandomItem(questHelperObj, weaponNode.forcePresets, true); // Use quest helper if enabled, otherwise random forced preset
            if (isDefined(globalsDB, `ItemPresets.${randNewWeapon}`)) {
                for (let thisGenerationAttempt = 0; thisGenerationAttempt < gunGenerationAttempts; thisGenerationAttempt++) { // Try 10 times to generate a valid gun
                    debugOut(functionDebug, `Selected from forced list ${randNewWeapon} => ${globalsDB.ItemPresets[randNewWeapon]._name}`, 2);

                    let weaponObj = newWeapon(botInventory, itemSlot, randNewWeapon, weaponNode, botRole); // Generate a new weapon based on this preset
                    newItemMods(weaponNode, weaponObj, botRole); // Modify weapon per settings

                    if (verifyWeaponValid(weaponObj)) { // If gun is valid, use it
                        addItemsToInventory(botInventory, weaponObj); // Add the weapon to the bot's inventory
                        break;
                    } else {
                        debugOut(functionDebug, `Generated invalid gun: ${presetName(randNewWeapon)}, ${gunGenerationAttempts - (thisGenerationAttempt + 1)} attempts remain`, 2, 'warning');
                    }
                }
            } else {
                debugOut(functionDebug, `${botRole} => ${botInventoryLevel}: forcePresets[${randNewWeapon}] is not a preset. Did you add the item ID by mistake?`, 0, 'error');
                return;
            }
        } else {
            let itemArray = utility.wipeDepend(dbNode.itemArray[weaponType]); // Copy item array of this weapon type presets from db

            if (weaponNode.forbidItems.length > 0) { // If there are forbidden items
                for (const thisItem of weaponNode.forbidItems) {
                    if (isDefined(itemArray, thisItem)) {
                        debugOut(functionDebug, `Forbidden ${weaponType}: ${thisItem}`, 3);
                        delete itemArray[thisItem]; // Remove forbidden items from array
                    }
                }
            }
            if (Object.keys(itemArray).length > 0) { // If there are still items in the array after removing forbidden items
                for (let thisItemIndex = Object.keys(itemArray).length - 1; thisItemIndex >= 0; thisItemIndex--) { // Iterate backwards to delete items
                    const thisItem = Object.keys(itemArray)[thisItemIndex];
                    if (itemArray[thisItem] < weaponNode.value_Min || itemArray[thisItem] > weaponNode.value_Max) { // If this item's value is less than the allowed minimum or greater than the allowed maximum
                        debugOut(functionDebug, `${weaponType} wrong price: ${thisItem}   ${weaponNode.value_Min}   ${itemArray[thisItem]}   ${weaponNode.value_Max}`, 3);
                        delete itemArray[thisItem]; // Remove from array
                    }
                }
                if (Object.keys(itemArray).length > 0) { // If there are still items in the array after removing cheap/expensive items
                    for (let thisGenerationAttempt = 0; thisGenerationAttempt < gunGenerationAttempts; thisGenerationAttempt++) { // Try 10 times to generate a valid gun
                        debugOut(functionDebug, `Selecting ${weaponType} from  ${Object.keys(itemArray).length} candidates`, 2);

                        randNewWeapon = questHelperGetRandomItem(questHelperObj, Object.keys(itemArray), true); // Use quest helper if enabled, otherwise random

                        debugOut(functionDebug, `Selected ${weaponType}: ${randNewWeapon} => ${globalsDB.ItemPresets[randNewWeapon]._name}`, 2);

                        let weaponObj = newWeapon(botInventory, itemSlot, randNewWeapon, weaponNode, botRole); // Generate a new weapon based on this preset
                        newItemMods(weaponNode, weaponObj, botRole); // Modify weapon per settings

                        if (verifyWeaponValid(weaponObj)) { // If gun is valid, use it
                            addItemsToInventory(botInventory, weaponObj); // Add the weapon to the bot's inventory
                            break;
                        } else {
                            debugOut(functionDebug, `Generated invalid gun: ${presetName(randNewWeapon)}, ${gunGenerationAttempts - (thisGenerationAttempt + 1)} attempts remain`, 2, 'warning');
                        }
                    }
                } else {
                    debugOut(functionDebug, `All ${weaponType}s are outside of allowable values. Role: ${botRole}   inventory: ${botInventoryLevel}`, 1, 'warning');
                }
            } else {
                debugOut(functionDebug, `All ${weaponType}s are forbidden. Role: ${botRole}   inventory: ${botInventoryLevel}`, 1, 'warning');
            }
        }
    } else {
        debugOut(functionDebug, `Weapon type: forced build. Role: ${botRole}   inventory: ${botInventoryLevel}`, 2);

        let weaponObj = newWeapon(botInventory, itemSlot, false, weaponNode, botRole); // Generate a new weapon based on this forced preset
        addItemsToInventory(botInventory, weaponObj); // Add the weapon to the bot's inventory as-is
    }

    return;
}

function newWeapon(botInventory, itemSlot, randNewWeapon, weaponNode, botRole) { // newWeapon generates a new weapon using a global preset
    const functionDebug = { name: 'dynamicBots.newWeapon', debugMode: 0 }; // Debug settings for this function
    let presetObj;
    if (randNewWeapon) {
        presetObj = utility.wipeDepend(globalsDB.ItemPresets[randNewWeapon]._items); // Copy preset from globals
    } else {
        if (Array.isArray(weaponNode.forceItemBuild[0])) {
            if (weaponNode.forceItemBuild.length > 1) {
                const randForceBuildIndex = getRandomInt(0, weaponNode.forceItemBuild.length - 1); // Pick a random build by index
                presetObj = utility.wipeDepend(weaponNode.forceItemBuild[randForceBuildIndex]); // Copy item from random forced build index
            } else { // Only one item in forced build
                presetObj = utility.wipeDepend(weaponNode.forceItemBuild[0]); // Copy item from only forced build index
            }
        } else {
            presetObj = utility.wipeDepend(weaponNode.forceItemBuild); // Copy item from forced build
        }
    }
    //console.info(presetObj);

    if (isDefined(presetObj[0], 'parentId')) { // Sometimes presets have parentIds on the lower, but only after a map has been loaded
        delete presetObj[0].parentId;
    }

    if (isDefined(presetObj[0], 'location')) { // Bug maybe with presets in locations.js? Seems like they're being overwritten or something
        delete presetObj[0].location;
        presetObj[0].slotId = itemSlot;
    }

    let parentArray = {};
    let removeIndices = [];

    for (const thisItem of presetObj) {
        if (thisItem.slotId == 'cartridges') {
            debugOut(functionDebug, `Marked cartridges for deletion: ${thisItem._id}`, 3);
            removeIndices.push(presetObj.indexOf(thisItem)); // Add to removal index (to be deleted after this loop so we don't resize the array in the middle of a for loop)
        } else if (!isDefined(thisItem, 'parentId')) { // This is the lower receiver
            newItemProperties(thisItem, weaponNode, botRole, true) // Send this item off to get durability and FIR status
            const newItemID = utility.generateNewItemId();
            debugOut(functionDebug, `New ID for lower: ${newItemID}`, 3);
            parentArray[thisItem._id] = newItemID;
            thisItem._id = newItemID;
            thisItem.parentId = botInventory.equipment;
            thisItem.slotId = itemSlot;
        } else {
            newItemProperties(thisItem, weaponNode, botRole) // Send this item off to get FIR status
            if (isDefined(parentArray, thisItem._id)) { // See if this item's ID already has a new _id (from being the parent of another item)
                debugOut(functionDebug, `Switched _id: ${thisItem._id} => ${parentArray[thisItem._id]}`, 3);
                thisItem._id = parentArray[thisItem._id]; // Set new _id
            } else {
                const newItemID = utility.generateNewItemId(); // Generate new item _id
                debugOut(functionDebug, `New _id: ${thisItem._id} => ${newItemID}`, 3);
                parentArray[thisItem._id] = newItemID;
                thisItem._id = newItemID;
            }

            if (isDefined(parentArray, thisItem.parentId)) { // See if this item's parentId is already in the list
                debugOut(functionDebug, `Switched parentId: ${thisItem._id}   ${thisItem.parentId} => ${parentArray[thisItem.parentId]}`, 3);
                thisItem.parentId = parentArray[thisItem.parentId]; // Set new parentid
            } else {
                const newParentID = utility.generateNewItemId(); // Generate new parentId
                debugOut(functionDebug, `New parentId: ${thisItem._id}   ${thisItem.parentId} => ${newParentID}`, 3);
                parentArray[thisItem.parentId] = newParentID;
                thisItem.parentId = newParentID;
            }
        }
    }

    if (removeIndices.length > 0) {
        for (const thisIndex of removeIndices) {
            presetObj.splice(thisIndex, 1); // Remove this item
        }
    }

    //console.info(presetObj);

    return presetObj;
}

function verifyWeaponValid(weaponObj) { // verifyWeaponValid verifies that a generated weapon has all required slots occupied
    const functionDebug = { name: 'dynamicBots.verifyWeaponValid', debugMode: 0 }; // Debug settings for this function
    //console.info(weaponObj);

    let isValid = true;

    let conflictArray = [];
    let requiredArray = {};
    for (const thisPart of weaponObj) {
        if (isDefined(thisPart, '_id') && isDefined(thisPart, '_tpl') && isDefined(thisPart, 'parentId') && isDefined(thisPart, 'slotId') && isDefined(itemDB, `${thisPart._tpl}._props.ConflictingItems`)) {
            if (itemDB[thisPart._tpl]._props.ConflictingItems.length > 0) { // If this item has conflicts
                for (const thisConflict of itemDB[thisPart._tpl]._props.ConflictingItems) {
                    if (!conflictArray.includes(thisConflict)) {
                        conflictArray.push(thisConflict); // Add conflict to all conflicts array
                    }
                }
            }

            if (isDefined(itemDB, `${thisPart._tpl}._props.Slots`)) {
                if (itemDB[thisPart._tpl]._props.Slots.length > 0) {
                    for (const thisSlot of itemDB[thisPart._tpl]._props.Slots) {
                        if (thisSlot._required) {
                            if (!isDefined(requiredArray, `thisPart._id`)) {
                                requiredArray[thisPart._id] = [];
                            }
                            requiredArray[thisPart._id].push(thisSlot._name);
                        }
                    }
                }
            }
        } else {
            debugOut(functionDebug, `Undefined property of part: ${thisPart._tpl}`, 0, 'error');
            isValid = false;
            break;
        }
    }

    if (isValid) {
        for (const thisPart of weaponObj) {
            if (conflictArray.includes(thisPart._tpl)) {
                debugOut(functionDebug, `Part conflicts with weapon: ${thisPart._tpl}`, 2, 'warning');
                isValid = false;
                break;
            }
        }
    }

    if (isValid) {
        for (const thisID in requiredArray) {
            for (const thisSlot of requiredArray[thisID]) {
                for (let i = 0; i < weaponObj.length; i++) {
                    if (weaponObj[i].parentId == thisID && weaponObj[i].slotId == thisSlot) {
                        break;
                    }
                    if (i == weaponObj.length - 1) {
                        debugOut(functionDebug, `Required slot missing: ${weaponObj[i]._tpl} -> ${thisSlot}`, 2, 'warning');
                        isValid = false;
                        break;
                    }
                }
            }
        }
    }

    if (isValid) {
        debugOut(functionDebug, 'Item is valid', 2);
    }

    return isValid;
}

function newItemProperties(itemObj, dbgItemSettingsNode, botRole, setDurability = false) { // newItemProperties takes an item that has just been generated and gives it properties based on settings, such as durability, found in raid status, etc
    const functionDebug = { name: 'dynamicBots.newItemProperties', debugMode: 0 }; // Debug settings for this function

    if (!isDefined(itemObj, 'upd')) {
        itemObj.upd = {};
    }

    if (setDurability) {
        if (isDefined(itemDB, `${itemObj._tpl}._props.MaxDurability`)) {
            const maxDurability = itemDB[itemObj._tpl]._props.MaxDurability;
            debugOut(functionDebug, `item: ${itemObj._tpl} -> maxDurability: ${maxDurability}`, 2);
            let durabilityObj = {
                'Durability': maxDurability,
                'MaxDurability': maxDurability
            };

            if (dbgItemSettingsNode.durability_Min < 100 || dbgItemSettingsNode.durability_Max < 100) {
                let durabilityMinPercent = Math.min(dbgItemSettingsNode.durability_Min, dbgItemSettingsNode.durability_Max); // Make sure the minimum value is actually smaller than the larger one because... users are users
                durabilityMinPercent = Math.min(durabilityMinPercent, 100); // Make sure some idiot didn't use a number bigger than 100
                durabilityMinPercent = Math.max(durabilityMinPercent, 0); // And make sure they didn't enter something smaller than 0

                let durabilityMaxPercent = Math.max(dbgItemSettingsNode.durability_Min, dbgItemSettingsNode.durability_Max);
                durabilityMaxPercent = Math.min(durabilityMaxPercent, 100);
                durabilityMaxPercent = Math.max(durabilityMaxPercent, 0);

                debugOut(functionDebug, `durabilityMinPercent: ${durabilityMinPercent}   durabilityMaxPercent: ${durabilityMaxPercent}`, 3);

                if (durabilityMinPercent < 100) {
                    const randomDurabilityPercent = randomBetweenNumbers(durabilityMinPercent, durabilityMaxPercent);
                    durabilityObj.Durability = Math.round(randomDurabilityPercent / 10 * maxDurability) / 10; // Round in the middle so we can carry one decimal place
                    debugOut(functionDebug, `randomDurabilityPercent: ${randomDurabilityPercent} = ${durabilityObj.Durability} durability`, 2);

                    const randomMaxDurabilityPercent = randomBetweenNumbers(randomDurabilityPercent, durabilityMaxPercent);
                    durabilityObj.MaxDurability = Math.round(randomMaxDurabilityPercent / 10 * maxDurability) / 10;
                    debugOut(functionDebug, `randomMaxDurabilityPercent: ${randomMaxDurabilityPercent} = ${durabilityObj.MaxDurability} max durability`, 2);
                }
            }

            itemObj.upd.Repairable = durabilityObj;
        } else {
            debugOut(functionDebug, `Item ${itemObj._tpl} in slot ${itemObj.slotId} is missing MaxDurability property`, 0, 'error');
            return;
        }
    }

    if (isDefined(itemDB, `${itemObj._tpl}._props.weapFireType`)) { // If this has the weapFireType property then it's probably a weapon lower receiver
        const fireModeArray = itemDB[itemObj._tpl]._props.weapFireType;
        if (fireModeArray.length > 0) {
            const fireModes = ['fullauto', 'burst', 'single']; // Prefer full auto, then prefer burst, then single if those aren't available

            for (const thisFireMode of fireModes) {
                if (fireModeArray.includes(thisFireMode)) { // If the rifle supports this fire mode
                    itemObj.upd.FireMode = { FireMode: thisFireMode }; // Set the fire mode on the rifle
                    break;
                }
            }
        }
    }

    if ((botRole == 'usec' || botRole == 'bear') && dbSettingsNode.pmcGearMarkedFoundInRaid) {
        itemObj.upd.SpawnedInSession = true;
    } else if (dbSettingsNode.scavGearMarkedFoundInRaid) {
        itemObj.upd.SpawnedInSession = true;
    }

    if (itemDB[itemObj._tpl]._props.HasHinge) {
        itemObj.upd.Togglable = { 'On': true };
    }

    if (itemDB[itemObj._tpl]._props.Foldable) {
        itemObj.upd.Foldable = { 'Folded': false };
    }

    if (itemDB[itemObj._tpl]._parent == '55818b084bdc2d5b648b4571' || itemDB[itemObj._tpl]._parent == '55818b164bdc2ddc698b456c') { // If this is a flashlight or combo tac device
        if (isDefined(itemDB, `${itemObj._tpl}._props.ModesCount`)) {
            itemObj.upd.Light = { 'IsActive': true, 'SelectedMode': getRandomInt(0, itemDB[itemObj._tpl]._props.ModesCount) }; // Give flashlight/laser a random mode
        }
    }

    return;
}

function newItemMods(dbgItemSettingsNode, itemObj, botRole) { // newItemMods takes a weapon that has just been generated and removes non-essential parts based on settings, then adds/swaps parts based on settings
    const functionDebug = { name: 'dynamicBots.newItemMods', debugMode: 0 }; // Debug settings for this function

    // Find ID of the base item (which all other items attach to or have parent chains that attach to)
    let baseItemID;
    let baseItemTPL;
    for (const thisItem of itemObj) {
        if (isDefined(thisItem, 'slotId')) {
            if (thisItem.slotId == 'FirstPrimaryWeapon' || thisItem.slotId == 'SecondPrimaryWeapon' || thisItem.slotId == 'Holster') {
                baseItemID = thisItem._id
                baseItemTPL = thisItem._tpl;
                break;
            }
        } else {
            debugOut(functionDebug, `no slotId ${thisItem._tpl}`, 3);
        }
    }

    if (baseItemTPL != null) {
        // Remove a non-essential part from the item
        missingPart(itemObj, dbgItemSettingsNode, baseItemTPL, baseItemID);

        let modBudget = randomBetweenNumbers(dbgItemSettingsNode.modBudget_Min, dbgItemSettingsNode.modBudget_Max); // Get random mod budget from settings
        debugOut(functionDebug, `modBudget: ${modBudget}`, 2);

        // Modify this item
        modBudget = addMods(dbgItemSettingsNode, itemObj, botRole, modBudget);

        debugOut(functionDebug, `after mods modBudget: ${modBudget}`, 2);

        let opticBudget = randomBetweenNumbers(dbgItemSettingsNode.opticBudget_Min, dbgItemSettingsNode.opticBudget_Max);
        debugOut(functionDebug, `opticBudget: ${opticBudget}`, 2);

        // Add an optic to this weapon
        addOptic(dbgItemSettingsNode, itemObj, botRole, opticBudget);
    } else {
        debugOut(functionDebug, `Item is missing base and can't be modified`, 0, 'error');
        console.info(itemObj);
        return;
    }

    return;
}

function missingPart(itemObj, dbgItemSettingsNode, baseItemTPL, baseItemID) { // missingPart is a function called by newItemMods that removes a non-essential part from an item
    const functionDebug = { name: 'dynamicBots.missingPart', debugMode: 0 }; // Debug settings for this function

    if (randomByPercent(dbgItemSettingsNode.chanceForAMissingPart)) { // Roll to determine if this item has a missing non-essential part
        let successfullyRemovedPart = false;
        let requiredSlots = {};
        let parentsArray = [];
        let requiredParts = [];
        let removableParts = [];

        for (const thisItem of itemObj) { // Iterate through all the individual parts of this weapon, check their item slots for the _required property to see what is actually needed for this weapon to function
            if (isDefined(itemDB, `${thisItem._tpl}._props.Slots`)) {
                if (itemDB[thisItem._tpl]._props.Slots.length > 0) { // If this item has mod slots
                    requiredSlots[thisItem._id] = [];
                    for (const thisSlot of itemDB[thisItem._tpl]._props.Slots) {
                        if (thisSlot._required) { // If this slot _required == true
                            requiredSlots[thisItem._id].push(thisSlot._name); // Push the unique _id for this item (not _tpl in case there's duplicate items with the same _tpl)
                        }
                    }
                } else {
                    debugOut(functionDebug, `Item ${thisItem._tpl} has no slots`, 3);
                }
            } else {
                debugOut(functionDebug, `Item ${thisItem._tpl} slots prop undefined`, 3, 'error');
            }

            if (isDefined(thisItem, 'parentId')) { // If this item has a parentId
                if (!parentsArray.includes(thisItem.parentId)) { // And this parentId isn't already in the array
                    parentsArray.push(thisItem.parentId);
                }
            }
        }

        for (const thisItem of itemObj) { // Add all the required parts to an array
            if (thisItem._id == baseItemID) {
                requiredParts.push(thisItem._id);
            } else {
                if (isDefined(requiredSlots, thisItem.parentId)) { // If this part's parent matches one of the items with required slots
                    if (requiredSlots[thisItem.parentId].includes(thisItem.slotId)) { // If this item's slot ID matches one of the required items from the parent
                        requiredParts.push(thisItem._id); // Add this item's unique _id to the required list
                    }
                }
            }
        }

        for (const thisItem of itemObj) { // Add all the non-essential items to an array
            if ((!requiredParts.includes(thisItem._id)) && (!parentsArray.includes(thisItem._id)) && (thisItem.slotId != 'mod_magazine')) { // If this item isn't in the required list, isn't a parent of any other item, and it's not a magazine
                removableParts.push(thisItem._id); // Then it's non-essential
            }
        }

        if (removableParts.length > 0) {
            const randPart = getRandomFromArray(removableParts); // Choose a random part

            for (let i = 0; i < itemObj.length; i++) {
                if (itemObj[i]._id == randPart) {
                    debugOut(functionDebug, `Removing part ${itemObj[i]._tpl} ${randPart}`, 2);
                    itemObj.splice(i, 1); // Remove the part from the weapon
                    break;
                }
                successfullyRemovedPart = true;
            }

            if (successfullyRemovedPart) {
                debugOut(functionDebug, `Part successfully removed`, 3);
            } else {
                debugOut(functionDebug, `Unable to remove part`, 3, 'error');
            }

        } else {
            debugOut(functionDebug, `This item ${baseItemTPL} has no non-essential parts`, 3);
        }
    } else {
        debugOut(functionDebug, `Bot failed roll for missing part`, 3);
    }
}

function addOptic(dbgItemSettingsNode, itemObj, botRole, opticBudget) { // addOptic attempts to add an optic to a weapon within the opticBudget
    const functionDebug = { name: 'dynamicBots.addOptic', debugMode: 0 }; // Debug settings for this function

    if (randomByPercent(dbgItemSettingsNode.chanceForOptic)) {
        let opticNode;
        let avoidMultiSlotMounts = false;
        if (randomByPercent(dbgItemSettingsNode.longRangeOptic)) { // If this bot rolls to use a long-range optic
            debugOut(functionDebug, `Rolled long-range optic`, 2);
            opticNode = dbNode.itemArray.optics;
        } else {
            debugOut(functionDebug, `Rolled reflex optic`, 2);
            opticNode = dbNode.itemArray.reflex;
            avoidMultiSlotMounts = true;
        }
        let scopeMountValueArray = {};

        for (const thisItem of itemObj) { // Iterate through parts to see if any have a mod_scope slot
            if (isDefined(itemDB, `${thisItem._tpl}._props.Slots`)) {
                if (itemDB[thisItem._tpl]._props.Slots.length > 0) { // If this item has mod slots
                    for (const thisSlot of itemDB[thisItem._tpl]._props.Slots) {
                        checkMountsForOptics(thisSlot, opticNode, opticBudget, scopeMountValueArray, itemDB[thisItem._tpl]._props.ConflictingItems, thisItem._id, avoidMultiSlotMounts); // Check this slots for optics or mounts for optics and add them to scopeMountValueArray
                    }
                } else {
                    debugOut(functionDebug, `Item ${thisItem._tpl} has no slots`, 3);
                }
            } else {
                debugOut(functionDebug, `Item ${thisItem._tpl} slots property undefined`, 3, 'error');
                continue;
            }
        }
        //console.info(scopeMountValueArray); // This is really pretty btw

        if (Object.keys(scopeMountValueArray).length > 0) { // There is a combination of mounts + optics possible within this budget
            const randNewOptic = getRandomFromArray(Object.keys(scopeMountValueArray)); // Randomly select one of the optic chains
            debugOut(functionDebug, `Selected chain: ${randNewOptic}`, 2);

            const newOpticArray = randNewOptic.split('|');

            let thisNewParent = newOpticArray[0]; // We stored the base item ID as the first entry in this string, therefore it's the 0th entry in this array
            for (let i = 1; i < newOpticArray.length; i++) {
                const partProps = newOpticArray[i].split('>'); // Split because first part contains the mod slot, second contains item ID
                let thisNewPart = utility.wipeDepend(newItem(partProps[1], thisNewParent, partProps[0])); // Create the new part

                newItemProperties(thisNewPart, dbgItemSettingsNode, botRole); // Send this part off to get FIR statis

                itemObj.push(thisNewPart); // Add this part to the weapon obj

                thisNewParent = thisNewPart._id; // This part will be the parent for the next part
            }
        } else {
            debugOut(functionDebug, `No compatible optics`, 3);
        }
    } else {
        debugOut(functionDebug, `Bot failed roll for optic`, 3);
    }

    return;
}

function checkMountsForOptics(slotObj, opticNode, opticBudget, scopeMountValueArray, conflictArray, parentChain, avoidMultiSlotMounts = false) { // checkMountsForOptics checks mount and scope slots for installable optics within the modBudget, while avoiding conflicts
    const functionDebug = { name: 'dynamicBots.checkMountsForOptics', debugMode: 0 }; // Debug settings for this function

    if (slotObj._name.startsWith('mod_scope') || slotObj._name.startsWith('mod_mount')) { // If this is a scope slot or mount of any kind
        if (isDefined(slotObj, '_props.filters')) {
            let thisConflictArray = [...conflictArray]; // Make a copy of the conflict array for this item

            for (const thisPart of slotObj._props.filters[0].Filter) { // Iterate through filtered parts to see which category each belongs to
                if (isDefined(itemDB, `${thisPart}`)) {
                    if (thisConflictArray.includes(thisPart)) {
                        debugOut(functionDebug, `Part ${thisPart} conflicts with something`, 2, 'warning');
                    } else {
                        thisConflictArray.push(...itemDB[thisPart]._props.ConflictingItems); // Add this part's conflicts to thisConflictArray for this iteration
                        if (isDefined(dbNode.itemArray.mounts, thisPart)) { // If this part is a mount
                            // The 'La Rue Tactical picatinny riser' and 'Aimpoint Micro Spacer High' fit on almost everything so a disproportionate number of generated builds include these parts
                            if ((thisPart != '5c064c400db834001d23f468' || randomByPercent(10)) && (thisPart != '58d39b0386f77443380bf13c' || randomByPercent(25))) { // Limits the number of builds that will include these parts
                                const thisOpticBudget = (opticBudget - dbNode.itemArray.mounts[thisPart]); // Subtract the cost of this part from the opticBudget

                                if (thisOpticBudget > 0) { // If the combined cost of these parts is within budget
                                    if (isDefined(itemDB, `${thisPart}._props.Slots`)) {
                                        if ((avoidMultiSlotMounts && itemDB[thisPart]._props.Slots.length == 1) || (!avoidMultiSlotMounts && itemDB[thisPart]._props.Slots.length > 0)) { // If this part has mod slots
                                            for (const thisSlot of itemDB[thisPart]._props.Slots) {
                                                checkMountsForOptics(thisSlot, opticNode, opticBudget, scopeMountValueArray, thisConflictArray, `${parentChain}|${slotObj._name}>${thisPart}`, avoidMultiSlotMounts) // Check this slots for optics or mounts for optics and add them to scopeMountValueArray
                                            }
                                        } else {
                                            debugOut(functionDebug, `Item ${thisPart} has no slots`, 3);
                                        }
                                    } else {
                                        debugOut(functionDebug, `Item ${thisPart} slots prop undefined`, 3, 'error');
                                        continue;
                                    }
                                }
                            } else {
                                debugOut(functionDebug, `Excluded riser`, 3);
                            }
                        } else if (isDefined(opticNode, thisPart)) { // If this part is a scope
                            const thisOpticBudget = (opticBudget - opticNode[thisPart]); // Subtract the cost of this part from the opticBudget

                            if (thisOpticBudget > 0) { // If the combined cost of these parts is within budget
                                let totalValue = 0;
                                const scopeParentChain = `${parentChain}|${slotObj._name}>${thisPart}`;
                                const scopeParentArray = scopeParentChain.split('|'); // Split the parent chain into an array
                                for (let i = 1; i < scopeParentArray.length; i++) { // Start at the first index since index 0 is the _id of the parent item
                                    let partProps = scopeParentArray[i].split('>'); // Split because first part contains the mod slot, second contains item ID
                                    if (isDefined(opticNode, partProps[1])) {
                                        totalValue += opticNode[partProps[1]]; // Add the value of each part
                                    } else {
                                        totalValue += dbNode.itemArray.mounts[partProps[1]];
                                    }
                                }

                                scopeMountValueArray[scopeParentChain] = totalValue; // Add this chain of parts and value to the array, to be randomly selected from in addOptic
                            }
                        }
                    }
                } else {
                    debugOut(functionDebug, `itemDB[${thisPart}] undefined`, 0, 'error');
                    return;
                }
            }
        }
    }
}

function addMods(dbgItemSettingsNode, itemObj, botRole, modBudget) { // addMods attempts to add mods to an item within the modBudget
    const functionDebug = { name: 'dynamicBots.addMods', debugMode: 0 }; // Debug settings for this function

    if (randomByPercent(dbgItemSettingsNode.chanceForMods)) {
        //console.info(itemObj);

        let allIDsArray = [];
        let allConflictsArray = [];
        let allParentsArray = [];
        let slotValueArray = {};
        for (const thisItem of itemObj) { // Iterate through items to make an array of the total value each slot and its child items is worth, for comparison when considering upgrades
            if (!allIDsArray.includes(thisItem._tpl)) {
                allIDsArray.push(thisItem._tpl); // Make a list of all item IDs so we can check for conflicting items
            }
            if (isDefined(itemDB, `${thisItem._tpl}._props.ConflictingItems`)) {
                if (itemDB[thisItem._tpl]._props.ConflictingItems.length > 0) { // If this item has conflicts
                    for (const thisConflict of itemDB[thisItem._tpl]._props.ConflictingItems) {
                        if (!allConflictsArray.includes(thisConflict)) {
                            allConflictsArray.push(thisConflict); // Add conflict to the list
                        }
                    }
                }
            }

            calculateSlotValue(slotValueArray, thisItem, itemObj, allParentsArray); // Calculate the value of all slots and the child parts that chain from them
        }

        let modValueArray;

        for (let i = 0; i < dbgItemSettingsNode.modMaxTries; i++) { // modMaxTries dictates the max number of passes to mod the item within budget
            modValueArray = {};
            for (const thisItem of itemObj) { // Iterate through items to make an array of slots and the items that can fit in them
                if (isDefined(itemDB, `${thisItem._tpl}._props.Slots`)) {
                    if (itemDB[thisItem._tpl]._props.Slots.length > 0) { // If this item has slots
                        for (const thisSlot of itemDB[thisItem._tpl]._props.Slots) { // Iterate through this item's slots
                            checkSlotsForMods(thisSlot, modBudget, thisItem._id, thisItem._id, modValueArray, allIDsArray, allConflictsArray, allParentsArray, itemObj, slotValueArray);
                        }
                    }
                } else {
                    debugOut(functionDebug, `Item ${thisItem._tpl} slots prop undefined`, 3, 'error');
                    continue;
                }
            }
            debugOut(functionDebug, `${Object.keys(modValueArray).length} mods are possible`, 2,);
            if (Object.keys(modValueArray).length == 0) { // If no more mods are possible within the budget
                break;
            } else { // Upgrades are possible
                if (isDefined(itemObj[0], 'slotId')) {
                    if (itemObj[0].slotId == 'Headwear') {
                        for (let thisModIndex = Object.keys(modValueArray).length - 1; thisModIndex >= 0; thisModIndex--) { // Iterate backwards since we might be deleting items
                            const thisModString = Object.keys(modValueArray)[thisModIndex]
                            if (thisModString.includes("mod_flashlight")) { // Don't put helmets on flashlights
                                delete modValueArray[thisModString];
                            }
                        }
                    }
                }

                if (Object.keys(modValueArray).length > 0) { // If there are still mods possible after deleting helmet flashlights
                    //console.info(modValueArray);
                    const randNewMod = getRandomFromArray(Object.keys(modValueArray)); // Randomly select one of the mod chains
                    debugOut(functionDebug, `Mod selected: ${randNewMod} => ${itemName(randNewMod)}`, 2);

                    const newModArray = randNewMod.split('|');

                    let thisNewParent = newModArray[0]; // We stored the base item ID as the first entry in this string, therefore it's the 0th entry in this array

                    for (let thisPartIndex = 1; thisPartIndex < newModArray.length; thisPartIndex++) {
                        let partProps = newModArray[thisPartIndex].split('>'); // Split because first part contains the mod slot, second contains item ID

                        if (thisPartIndex == 1) { // If this is the first item in the mod chain then we have the slot that this part will occupy, which could be replacing an existing part
                            for (let itemIndex = 0; itemIndex < itemObj.length; itemIndex++) { // Iterate through the item to see if this part already exists in this slot

                                if ((itemObj[itemIndex].parentId == thisNewParent) && (itemObj[itemIndex].slotId == partProps[0])) { // If there's a parentID and slotId match in the item
                                    debugOut(functionDebug, `Removing existing part: ${itemObj[itemIndex]._id} for upgrade`, 3, 'warning');
                                    itemObj.splice(itemIndex, 1); // Remove the existing part

                                    break;
                                }
                            }
                        }

                        let thisNewPart = utility.wipeDepend(newItem(partProps[1], thisNewParent, partProps[0])); // Create the new part

                        newItemProperties(thisNewPart, dbgItemSettingsNode, botRole); // Send this part off to get FIR statis

                        //console.info(thisNewPart);

                        itemObj.push(thisNewPart); // Add this part to the weapon obj

                        thisNewParent = partProps[1]; // This part will be the parent for the next part

                        allIDsArray.push(partProps[1]); // Add to IDs to check for future conflicts
                        if (isDefined(itemDB, `${partProps[1]}._props.ConflictingItems`)) {
                            if (itemDB[partProps[1]]._props.ConflictingItems.length > 0) { // If this item has conflicts
                                for (const thisConflict of itemDB[partProps[1]]._props.ConflictingItems) {
                                    if (!allConflictsArray.includes(thisConflict)) {
                                        allConflictsArray.push(thisConflict); // Add conflict to the list
                                    }
                                }
                            }
                        }

                        slotValueArray = {}; // Erase previous array (in case a part was removed)
                        allParentsArray = [];
                        for (const thisItem of itemObj) {
                            calculateSlotValue(slotValueArray, thisItem, itemObj, allParentsArray);
                        }
                    }

                    modBudget = modBudget - modValueArray[randNewMod]; // Subtract the total value of the mod from the modbudget
                }
            }
        }

    } else {
        debugOut(functionDebug, `Bot failed roll for mods`, 3);
    }

    return modBudget;
}

function calculateSlotValue(slotValueArray, thisItem, itemObj, allParentsArray) { // calculateSlotValue calculates the value of each invididual slot of a compound item and its children
    if (thisItem.slotId != 'Headwear' && thisItem.slotId != 'FirstPrimaryWeapon' && thisItem.slotId != 'SecondPrimaryWeapon' && thisItem.slotId != 'Holster') {
        if (!allParentsArray.includes(thisItem.parentId)) {
            allParentsArray.push(thisItem.parentId); // Make a list of items that are the parent of another item so we don't replace a part that has child parts
        }

        let thisSlotValue = dbNode.itemArray.allItems[thisItem._tpl]; // Set initial value to the part that is this slot

        let parentArray = [thisItem._id]; // We need to find out if the current item in this slot has any child objects to get the total value of this slot
        for (const thisParent of parentArray) {
            for (const thisChild of itemObj) {
                if (thisChild.parentId == thisParent) {
                    parentArray.push(thisChild._id); // Add this as a potential parent
                    thisSlotValue = thisSlotValue + dbNode.itemArray.allItems[thisChild._tpl]; // Add the value of all child parts to the parent to get the total value of this slot
                }
            }
        }

        slotValueArray[thisItem._id] = thisSlotValue; // Record total value of the item in this slot plus all children
    }
}

function checkSlotsForMods(slotObj, modBudget, parentID, parentChain, modValueArray, allIDsArray, allConflictsArray, allParentsArray, itemObj, slotValueArray) { // checkSlotsForMods checks a slot for installable mods within the modBudget, while avoiding conflicts
    const functionDebug = { name: 'dynamicBots.checkSlotsForMods', debugMode: 0 }; // Debug settings for this function

    if (!(slotObj._name.startsWith('mod_scope')) && !(slotObj._name.startsWith('mod_launcher')) && isDefined(slotObj, '_props.filters')) { // Don't replace optics and don't install underbarrel grenade launchers
        for (const thisPart of slotObj._props.filters[0].Filter) { // Iterate through the parts that fit this item's slot
            if (!allConflictsArray.includes(thisPart)) { // Make sure this part doesn't conflict with any other items in this build
                if (isDefined(itemDB, `${thisPart}`)) {
                    if (isDefined(itemDB, `${thisPart}._props.ConflictingItems`)) {
                        if (!itemDB[thisPart]._props.ConflictingItems.includes(allIDsArray)) { // Make sure none of the IDs in this item are on this part's ConflictingItems list
                            if (isDefined(dbNode, `itemArray.allItems.${thisPart}`)) {
                                let thisModBudget = (modBudget - dbNode.itemArray.allItems[thisPart]); // Subtract the cost of this part from the modBudget
                                if (thisModBudget > 0) { // If the combined cost of these parts is within budget
                                    let matchSlot = false;
                                    let samePart = false;
                                    if (typeof itemObj != 'undefined') { // Will be undefined on nested iterations
                                        for (const thisObj of itemObj) { // Check to see if this slot is already occupied by an item

                                            //debugOut(functionDebug, `${thisObj.parentId}==${parentID}   ${thisObj.slotId}==${slotObj._name}`, 1);
                                            if ((thisObj.parentId == parentID) && (thisObj.slotId == slotObj._name)) { // Match parent ID and slot name
                                                matchSlot = true;

                                                //debugOut(functionDebug, `Existing part: ${thisObj._tpl}   thisPart: ${thisPart}`, 1);
                                                if (thisObj._tpl == thisPart) { // Check to make sure we're not trying to replace this part with the same part
                                                    samePart = true;
                                                } else if (isDefined(slotValueArray, `${thisObj._id}`) && (slotValueArray[thisObj._id] < dbNode.itemArray.allItems[thisPart])) { // If the new part is an upgrade (by value) over the part(s) already in this slot
                                                    let allowThisPart = true;

                                                    if (itemDB[thisPart]._props.Slots.length > 0) { // If this item has slots
                                                        for (const thisSlot of itemDB[thisPart]._props.Slots) { // Iterate through this item's slots
                                                            if (thisSlot._name.startsWith('mod_stock') || thisSlot._name.startsWith('mod_nvg')) { // Don't allow items with missing stock or nvg slots to be added
                                                                debugOut(functionDebug, `Part chain ${parentChain}|${slotObj._name}>${thisPart} ends with mod_stock or mod_nvg slot`, 2);
                                                                allowThisPart = false;
                                                            }
                                                        }
                                                    }

                                                    if (allowThisPart) {
                                                        debugOut(functionDebug, `Part chain ${parentID}|${slotObj._name}>${thisPart} is an upgrade over ${thisObj._id}`, 2);
                                                        modValueArray[`${parentID}|${slotObj._name}>${thisPart}`] = dbNode.itemArray.allItems[thisPart]; // Add this part chain w/ cost to modValueArray
                                                    }
                                                }

                                                break;
                                            }
                                        }
                                    }

                                    if (!samePart && (!matchSlot || !allParentsArray.includes(parentID))) { // If there's no part in this slot or if the part in this slot has no child parts
                                        let allowThisPart = true;
                                        if (isDefined(itemDB, `${thisPart}._props.Slots`)) {
                                            if (itemDB[thisPart]._props.Slots.length > 0) { // If this item has slots
                                                for (const thisSlot of itemDB[thisPart]._props.Slots) { // Iterate through this item's slots
                                                    if (thisSlot._name.startsWith('mod_stock') || thisSlot._name.startsWith('mod_flashlight') || thisSlot._name.startsWith('mod_nvg')) { // Don't allow items with unfilled stock, flashlight, or nvg slots to be added
                                                        debugOut(functionDebug, `Part chain ${parentChain}|${slotObj._name}>${thisPart} ends with mod_stock, mod_flashlight, or mod_nvg slot`, 2);
                                                        allowThisPart = false;
                                                    }
                                                    checkSlotsForMods(thisSlot, thisModBudget, thisPart, `${parentChain}|${slotObj._name}>${thisPart}`, modValueArray, allIDsArray, allConflictsArray, allParentsArray);
                                                }
                                            }
                                        } else {
                                            debugOut(functionDebug, `Part ${thisPart} slots prop undefined`, 3, 'error');
                                            continue;
                                        }

                                        if (!slotObj._name.startsWith('mod_mount') && allowThisPart) { // No sense adding a mount without anything on it, a stock mount without a stock, or a NVG mount without NVGs
                                            let totalValue = 0;
                                            const thisParentChain = `${parentChain}|${slotObj._name}>${thisPart}`;
                                            const thisParentArray = thisParentChain.split('|'); // Split the parent chain into an array
                                            for (let i = 1; i < thisParentArray.length; i++) { // Start at the first index since index 0 is the _id of the parent item
                                                const partProps = thisParentArray[i].split('>'); // Split because first part contains the mod slot, second contains item ID
                                                totalValue += dbNode.itemArray.allItems[partProps[1]];
                                            }
                                            debugOut(functionDebug, `Part chain ${parentChain}|${slotObj._name}>${thisPart} totalValue: ${totalValue}`, 2);

                                            modValueArray[thisParentChain] = totalValue; // Add this chain of parts and value to the array, to be randomly selected from in addMods
                                        }
                                    }
                                }
                            } else {
                                debugOut(functionDebug, `Part ${thisPart} missing from cached mods`, 0, 'error');
                                return;
                            }
                        } else {
                            debugOut(functionDebug, `Parts in this build conflict with ${thisPart}`, 3, 'error');
                        }
                    } else {
                        debugOut(functionDebug, `Part ${thisPart} ConflictingItems undefined`, 0, 'error');
                        return;
                    }
                } else {
                    debugOut(functionDebug, `Part ${thisPart} undefined`, 0, 'error');
                    return;
                }
            } else {
                debugOut(functionDebug, `Part ${thisPart} conflicts with another part in this build`, 3, 'error');
            }
        }
    } else {
        //debugOut(functionDebug, `Item ${thisItem._tpl}>${slotObj._name} _props.filters undefined`, 3, 'error');
    }
}

function newMagsAndAmmo(botInventory, botRole, dbgBotSettings, botInventoryLevel, questHelperObj, isPlayerBot) { // newMagsAndAmmo goes through the bot's inventory, generates the correct number of mags based on settings, then fills them with ammo based on settings
    const functionDebug = { name: 'dynamicBots.newMagsAndAmmo', debugMode: 0 }; // Debug settings for this function

    let newItems = []; // Define array to which new mags and ammo objects will be added
    let placeInBotInventory = []; // Define array that will contain item objects that need to be parented to containers in the bot's inventory

    let placeInSecureContainer = []; // Define array that will contain item objects that need to be parented to the bot's secure container
    const magsInSecureContainer = 4; // Number of copies of full mags to place in the bot's secure container
    const stacksInSecureContainer = 8; // Number of full ammo stacks to place in the bot's secure container

    for (const thisItem of botInventory.items) { // Iterate through all items in this bot's inventory
        if (isDefined(thisItem, 'slotId')) {
            if (thisItem.slotId == 'FirstPrimaryWeapon' || thisItem.slotId == 'SecondPrimaryWeapon' || thisItem.slotId == 'Holster') { // If this item is a weapon
                debugOut(functionDebug, `${botRole}.${botInventoryLevel} -> ${thisItem._tpl} slot: ${thisItem.slotId} => ${itemName(thisItem._tpl)}`, 2);
                let thisWeaponNode;
                if (thisItem.slotId == 'Holster') {
                    thisWeaponNode = dbgBotSettings[botInventoryLevel].weapons.pistol; // Read from pistol settings
                } else {
                    thisWeaponNode = dbgBotSettings[botInventoryLevel].weapons.primary; // Read from rifle settings
                }
                debugOut(functionDebug, `Ammo settings: value = ${thisWeaponNode.bullet_ValueMin}-${thisWeaponNode.bullet_ValueMax}, dmg < ${thisWeaponNode.bulletDmg_Max}, pen < ${thisWeaponNode.bulletPen_Max}`, 3);

                let randAmmo; // Will contain the random ammo chosen for this gun, its mags, and extra stacks in the bot's secure container
                if (isDefined(itemDB, `${thisItem._tpl}._props.ammoCaliber`)) {
                    const thisAmmoCaliber = itemDB[thisItem._tpl]._props.ammoCaliber;
                    if (typeof dbNode.ammoCaliber[thisAmmoCaliber] != 'undefined') { // Can't use isDefined because ammo calibers contain periods
                        const thisAmmoCaliberArray = dbNode.ammoCaliber[thisAmmoCaliber];

                        let ammoArray = []; // Array will contain ammo within budget requirements
                        for (const thisAmmo of dbNode.ammoCaliber[thisAmmoCaliber]) {
                            const thisAmmoValue = dbNode.itemArray.ammo[thisAmmo];
                            if (isDefined(itemDB, `${thisAmmo}._props.Damage`) && isDefined(itemDB, `${thisAmmo}._props.PenetrationPower`)) {
                                const thisAmmoDmg = itemDB[thisAmmo]._props.Damage;
                                const thisAmmoPen = itemDB[thisAmmo]._props.PenetrationPower;

                                if (thisAmmoValue > thisWeaponNode.bullet_ValueMin && thisAmmoValue < thisWeaponNode.bullet_ValueMax && thisAmmoDmg <= thisWeaponNode.bulletDmg_Max && thisAmmoPen <= thisWeaponNode.bulletPen_Max) { // If this ammo is within value, damage, and pen limits
                                    debugOut(functionDebug, `${botRole}.${botInventoryLevel} -> ${thisItem._tpl} -> Ammo: ${thisAmmo} Value: ${thisAmmoValue} Dmg: ${thisAmmoDmg} Pen: ${thisAmmoPen}`, 3);
                                    ammoArray.push(thisAmmo);
                                }
                            } else {
                                debugOut(functionDebug, `${botRole}.${botInventoryLevel} -> ${thisItem._tpl} -> ${thisAmmo} ammo missing Damage or PenetrationPower property`, 0, 'error');
                                return;
                            }
                        }

                        if (ammoArray.length > 0) { // If any ammos were within budget, damage, and pen settings
                            randAmmo = getRandomFromArray(ammoArray); // Pick an ammo at random
                            debugOut(functionDebug, `${botRole}.${botInventoryLevel} -> ${thisItem._tpl} Randomly selected ammo: ${randAmmo} => ${itemName(randAmmo)}`, 2);
                        } else {
                            if (thisAmmoCaliberArray.length == 1) {
                                debugOut(functionDebug, `${botRole}.${botInventoryLevel} -> ${thisItem._tpl} all ammo outside of defined settings. Defaulting to only available ammo`, 2, 'warning');
                                randAmmo = thisAmmoCaliberArray[0]; // Set to the only ammo type
                            } else {
                                debugOut(functionDebug, `${botRole}.${botInventoryLevel} -> ${thisItem._tpl} all ammo outside of defined settings. Defaulting to closest ammo by value`, 2, 'warning');
                                let closestAmmo = thisAmmoCaliberArray[0]; // Set initial type so we have something to compare to
                                let thisAmmoValue = dbNode.itemArray.ammo[closestAmmo];
                                let closestValueDifference = Math.min(Math.abs(thisWeaponNode.bullet_ValueMin - thisAmmoValue), Math.abs(thisWeaponNode.bullet_ValueMax - thisAmmoValue)); // Compare the difference between max and min value
                                debugOut(functionDebug, `${botRole}.${botInventoryLevel} -> ${thisItem._tpl} Ammo ${closestAmmo} value difference: ${closestValueDifference}`, 3);

                                for (let thisAmmoIndex = 1; thisAmmoIndex < thisAmmoCaliberArray.length; thisAmmoIndex++) {
                                    const thisAmmo = thisAmmoCaliberArray[thisAmmoIndex];
                                    thisAmmoValue = dbNode.itemArray.ammo[thisAmmo];
                                    const thisValueDifference = Math.min(Math.abs(thisWeaponNode.bullet_ValueMin - thisAmmoValue), Math.abs(thisWeaponNode.bullet_ValueMax - thisAmmoValue));

                                    if (thisValueDifference < closestValueDifference) { // If this ammo is cheaper than the one we currently have selected
                                        debugOut(functionDebug, `${botRole}.${botInventoryLevel} -> ${thisItem._tpl} Ammo ${thisAmmo} has lower value difference: ${thisValueDifference}`, 3);
                                        closestAmmo = thisAmmo; // Select the closer ammo
                                        closestValueDifference = thisValueDifference;
                                    }
                                }

                                randAmmo = closestAmmo;
                            }
                        }

                        debugOut(functionDebug, `${botRole}.${botInventoryLevel} -> ${thisItem._tpl} Selected ammo type: ${randAmmo} => ${itemName(randAmmo)}`, 2);
                    } else {
                        debugOut(functionDebug, `${botRole}.${botInventoryLevel} -> ${thisItem._tpl} no ammo exists in caliber: ${thisAmmoCaliber}`, 0, 'error');
                        return;
                    }
                } else {
                    debugOut(functionDebug, `${botRole}.${botInventoryLevel} -> ${thisItem._tpl} undefined weapon caliber`, 0, 'error');
                    return;
                }

                if (!isPlayerBot && isDefined(itemDB, `${randAmmo}._props.StackMaxSize`)) { // Add ammo stacks to secure container because bots like to empty whole mags into walls
                    const maxStackSize = itemDB[randAmmo]._props.StackMaxSize;
                    debugOut(functionDebug, `${botRole}.${botInventoryLevel} -> ${thisItem._tpl} Added ${stacksInSecureContainer} stacks of ${maxStackSize} to secure container`, 3);

                    for (let thisSecContainerStack = 0; thisSecContainerStack < stacksInSecureContainer; thisSecContainerStack++) {
                        let newAmmoStack = utility.wipeDepend(newItem(randAmmo, null, 'cartridges')); // Create with null parent because it will be placed in a container at the end of this function
                        newAmmoStack.upd = {}; // Define upd property
                        newAmmoStack.upd.StackObjectsCount = maxStackSize; // Set stack size

                        newItems.push(newAmmoStack);
                        placeInSecureContainer.push(newAmmoStack); // Add this stack to the list of items that will need to be parented to a container in the bot's inventory
                    }
                }

                if (isDefined(itemDB[thisItem._tpl]._props, 'Chambers')) { // If this weapon has chambers defined
                    for (const thisChamber of itemDB[thisItem._tpl]._props.Chambers) {
                        if (isDefined(thisChamber, '_props')) {
                            if (isDefined(itemDB, `${thisItem._tpl}._props.isChamberLoad`)) {
                                if (itemDB[thisItem._tpl]._props.isChamberLoad) { // If this weapon can be chamber loaded
                                    debugOut(functionDebug, `${botRole}.${botInventoryLevel} -> ${thisItem._tpl} Added round to chamber`, 3);
                                    let newChamberLoad = utility.wipeDepend(newItem(randAmmo, thisItem._id, 'patron_in_weapon')); // Create a round in the chamber of this weapon
                                    newItems.push(newChamberLoad);
                                } else {
                                    debugOut(functionDebug, `${botRole}.${botInventoryLevel} -> ${thisItem._tpl} this weapon can't be chamber loaded`, 2);
                                }
                            }
                        }
                    }
                }

                let thisMagazine;
                for (const thisPart of botInventory.items) {
                    if (isDefined(thisPart, 'parentId') && isDefined(thisPart, 'slotId')) {
                        if (thisPart.parentId == thisItem._id && thisPart.slotId.startsWith('mod_magazine')) { // Find the mag for this weapon
                            thisMagazine = thisPart;
                            break;
                        }
                    }
                }

                if (thisMagazine == null) { // This weapon did not come with a magazine
                    let magazineFilter;
                    for (const thisSlot of itemDB[thisItem._tpl]._props.Slots) { // Search for the magazine slot of the weapon
                        if (thisSlot._name == 'mod_magazine') {
                            magazineFilter = thisSlot._props.filters[0].Filter; // Get a list of compatible magazines
                            break;
                        }
                    }

                    if (magazineFilter != null && magazineFilter.length > 0) { // If the magazine slot was found
                        const randMagazine = questHelperGetRandomItem(questHelperObj, magazineFilter); // Use quest helper if enabled, otherwise random
                        let newMagazine = utility.wipeDepend(newItem(randMagazine, thisItem._id, 'mod_magazine')); // Create new magazine attached to this rifle
                        newItems.push(newMagazine);
                        thisMagazine = newMagazine;
                    }
                }

                const thisMagProps = itemDB[thisMagazine._tpl]._props;
                let thisCartridgeObj;
                if (isDefined(thisMagProps, 'Cartridges')) {
                    thisCartridgeObj = thisMagProps.Cartridges[0]
                    if (typeof thisCartridgeObj != 'undefined') {
                        debugOut(functionDebug, `${botRole}.${botInventoryLevel} -> ${thisItem._tpl} Adding ammo to mag ${thisMagazine._tpl}, size: ${thisCartridgeObj._max_count}`, 2);
                        let newAmmoStack = utility.wipeDepend(newItem(randAmmo, thisMagazine._id, 'cartridges'));
                        newAmmoStack.location = 0;
                        newAmmoStack.upd = { // Define upd property
                            'StackObjectsCount': thisCartridgeObj._max_count // Fill the mag completely
                        };
                        newItems.push(newAmmoStack);
                    }
                } else {
                    debugOut(functionDebug, `${botRole}.${botInventoryLevel} -> ${thisItem._tpl} Magazine ${thisMagazine._tpl} has no defined cartridge slot`, 0, 'error');
                    return;
                }

                if (isDefined(thisMagProps, 'ReloadMagType')) {
                    if (thisMagProps.ReloadMagType == 'InternalMagazine') { // If this is an internal mag, put a stack of loose rounds in the bot's inventory
                        if (isDefined(itemDB, `${randAmmo}._props.StackMaxSize`)) {
                            const maxStackSize = itemDB[randAmmo]._props.StackMaxSize;
                            const minStackSize = Math.floor(itemDB[randAmmo]._props.StackMaxSize * 0.25); // Minimum stack size is 25% of a stack
                            const randStackSize = getRandomInt(minStackSize, maxStackSize); // Ensure the random number chosen is an integer

                            let newAmmoStack = utility.wipeDepend(newItem(randAmmo, null, 'cartridges')); // Create with null parent because it will be placed in a container at the end of this function
                            newAmmoStack.upd = {}; // Define upd property
                            newAmmoStack.upd.StackObjectsCount = randStackSize; // Set stack size

                            newItems.push(newAmmoStack);
                            placeInBotInventory.push(newAmmoStack); // Add this stack to the list of items that will need to be parented to a container in the bot's inventory
                        } else {
                            debugOut(functionDebug, `${botRole}.${botInventoryLevel} -> ${thisItem._tpl} Ammo ${randAmmo} has no defined StackMaxSize`, 0, 'error');
                            return;
                        }

                    } else { // If this is an external mag, create new mags in tac vest/pockets, then load them with rounds
                        const randExtraMags = getRandomInt(thisWeaponNode.extraMags_Min, thisWeaponNode.extraMags_Max); // Random number of extra mags
                        debugOut(functionDebug, `${botRole}.${botInventoryLevel} -> ${thisItem._tpl} randExtraMags: ${randExtraMags} `, 2);
                        if (thisWeaponNode.matchMags) { // If these mags should match what's already in the rifle
                            for (let i = 0; i < randExtraMags; i++) {
                                let thisNewMag = utility.wipeDepend(newItem(thisMagazine._tpl, null, 'mod_magazine')); // Create new mag

                                debugOut(functionDebug, `${botRole}.${botInventoryLevel} -> ${thisItem._tpl} Adding ammo to extra mag ${thisMagazine._tpl}, size: ${thisCartridgeObj._max_count}`, 2);
                                let newAmmoStack = utility.wipeDepend(newItem(randAmmo, thisNewMag._id, 'cartridges')); // Create the ammo stack that goes in the mag
                                newAmmoStack.location = 0;
                                newAmmoStack.upd = { // Define upd property
                                    'StackObjectsCount': thisCartridgeObj._max_count // Fill the mag completely
                                };

                                newItems.push(thisNewMag);
                                placeInBotInventory.push(thisNewMag);
                                newItems.push(newAmmoStack);

                                if (!isPlayerBot) { // Add extra full mags to secure container because bots like to empty whole mags into walls
                                    debugOut(functionDebug, `${botRole}.${botInventoryLevel} -> Added extra ${magsInSecureContainer}x ${thisNewMag._tpl} mags to secure container`, 3);

                                    for (let thisSecContainerMag = 0; thisSecContainerMag < magsInSecureContainer; thisSecContainerMag++) {
                                        let secContainerMagObj = utility.wipeDepend(newItem(thisMagazine._tpl, null, 'mod_magazine')); // Create new mag
                                        let secContainerMagAmmo = utility.wipeDepend(newItem(randAmmo, secContainerMagObj._id, 'cartridges')); // Create the ammo stack that goes in the mag

                                        secContainerMagAmmo.location = 0;
                                        secContainerMagAmmo.upd = { // Define upd property
                                            'StackObjectsCount': thisCartridgeObj._max_count // Fill the mag completely
                                        };

                                        newItems.push(secContainerMagObj);
                                        placeInSecureContainer.push(secContainerMagObj);
                                        newItems.push(secContainerMagAmmo);
                                    }
                                }
                            }
                        } else { // Give this bot mismatched mags that are less than or equal to the capacity of the existing mag
                            let magArray;

                            for (const thisSlot of itemDB[thisItem._tpl]._props.Slots) { // Iterate through weapon's slots to find mod_magazine slot
                                if (thisSlot._name.startsWith('mod_magazine')) {
                                    magArray = [...thisSlot._props.filters[0].Filter]; // Copy mag filters
                                    break;
                                }
                            }

                            if (isDefined(magArray, 'length')) { // If length is defined then this is an array
                                for (let thisMagIndex = magArray.length - 1; thisMagIndex >= 0; thisMagIndex--) { // Iterate backwards because we'll be removing mags that are too big or valuable
                                    if (isDefined(itemDB, `${magArray[thisMagIndex]}._props.CreditsPrice`) && isDefined(itemDB, `${magArray[thisMagIndex]}._props.Cartridges`)) {
                                        const thisMagValue = itemDB[magArray[thisMagIndex]]._props.CreditsPrice;
                                        const thisMagCapacity = itemDB[magArray[thisMagIndex]]._props.Cartridges[0]._max_count;

                                        if (thisMagProps.CreditsPrice < thisMagValue || thisCartridgeObj._max_count < thisMagCapacity) { // If this mag's capacity or value exceeds the current mag
                                            magArray.splice(thisMagIndex, 1); // Remove it from the array
                                        }
                                    } else {
                                        debugOut(functionDebug, `${botRole}.${botInventoryLevel} -> ${thisItem._tpl} -> this magazine ${magArray[thisMagIndex]} has undefined CreditsPrice or Cartridges`, 0, 'error');
                                        return;
                                    }
                                }

                                if (magArray.length > 0) { // If there are still mags remaining (this should never happen because even if we're using the worst mag its value or capacity won't exceed itself so it will remain in the array)
                                    for (let i = 0; i < randExtraMags; i++) {
                                        const thisNewMagID = questHelperGetRandomItem(questHelperObj, magArray); // Use quest helper if enabled, otherwise random

                                        let thisNewMag = utility.wipeDepend(newItem(thisNewMagID, null, 'mod_magazine')); // Create new mag item

                                        const thisNewMagCapacity = itemDB[thisNewMagID]._props.Cartridges[0]._max_count;

                                        debugOut(functionDebug, `${botRole}.${botInventoryLevel} -> ${thisItem._tpl} Adding ammo to random mag ${thisNewMagID}, size: ${thisNewMagCapacity}`, 2);
                                        let newAmmoStack = utility.wipeDepend(newItem(randAmmo, thisNewMag._id, 'cartridges')); // Create the ammo stack that goes in the mag
                                        newAmmoStack.location = 0;
                                        newAmmoStack.upd = { // Define upd property
                                            'StackObjectsCount': thisNewMagCapacity // Fill the mag completely
                                        };

                                        newItems.push(thisNewMag);
                                        placeInBotInventory.push(thisNewMag);
                                        newItems.push(newAmmoStack);

                                        if (!isPlayerBot) { // Add extra full mags to secure container because bots like to empty whole mags into walls
                                            debugOut(functionDebug, `${botRole}.${botInventoryLevel} -> Added extra ${magsInSecureContainer}x ${thisNewMag._tpl} mags to secure container`, 3);

                                            for (let thisSecContainerMag = 0; thisSecContainerMag < magsInSecureContainer; thisSecContainerMag++) {
                                                let secContainerMagObj = utility.wipeDepend(newItem(thisNewMag._tpl, null, 'mod_magazine')); // Create new mag
                                                let secContainerMagAmmo = utility.wipeDepend(newItem(randAmmo, secContainerMagObj._id, 'cartridges')); // Create the ammo stack that goes in the mag

                                                secContainerMagAmmo.location = 0;
                                                secContainerMagAmmo.upd = { // Define upd property
                                                    'StackObjectsCount': thisNewMagCapacity // Fill the mag completely
                                                };

                                                newItems.push(secContainerMagObj);
                                                placeInSecureContainer.push(secContainerMagObj);
                                                newItems.push(secContainerMagAmmo);
                                            }
                                        }
                                    }
                                } else {
                                    debugOut(functionDebug, `${botRole}.${botInventoryLevel} -> ${thisItem._tpl} -> All mags have been removed from the random mag pool`, 0, 'error');
                                    return;
                                }

                            } else {
                                debugOut(functionDebug, `${botRole}.${botInventoryLevel} -> ${thisItem._tpl} unable to locate mod_magazine filter`, 0, 'error');
                                return;
                            }
                        }
                    }
                }
            }
        }
    }

    if (newItems.length > 0) { // If new items were created
        for (const thisItem of newItems) {
            newItemProperties(thisItem, dbgBotSettings[botInventoryLevel], botRole); // Send it off to get FIR status
        }

        if (placeInBotInventory.length > 0) {
            const itemDiscardArray = addItemsToContainers(botInventory, placeInBotInventory, ['TacticalVest', 'Pockets', 'Backpack'], true); // Parent items to containers in the bot's inventory and give them location info
            if (itemDiscardArray.length > 0) {
                for (let i = newItems.length - 1; i >= 0; i--) { // Iterate backwards to remove elements
                    if (itemDiscardArray.includes(newItems[i]._id)) {
                        debugOut(functionDebug, `Removed unplaceable inventory item ${newItems[i]._id} -> ${newItems[i]._tpl}`, 2);
                        newItems.splice(i, 1); // Remove it from the array
                    }
                }
            }
        }
        if (placeInSecureContainer.length > 0) {
            const itemDiscardArray = addItemsToContainers(botInventory, placeInSecureContainer, ['SecuredContainer'], true); // Parent items to the bot's secure container
            if (itemDiscardArray.length > 0) {
                for (let i = newItems.length - 1; i >= 0; i--) { // Iterate backwards to remove elements
                    if (itemDiscardArray.includes(newItems[i]._id)) {
                        debugOut(functionDebug, `Removed unplaceable secure container item ${newItems[i]._id} -> ${newItems[i]._tpl}`, 2);
                        newItems.splice(i, 1); // Remove it from the array
                    }
                }
            }
        }

        //console.info(newItems);
        botInventory.items.push(...newItems); // Add the contents of newItems to the bot's inventory
    }

    return;
}

function newGrenades(botInventory, botRole, dbgBotSettings, botInventoryLevel, questHelperObj) { // newGrenades adds grenades to a bot's inventory based on settings
    const functionDebug = { name: 'dynamicBots.newGrenades', debugMode: 0 }; // Debug settings for this function

    const nadeNode = dbgBotSettings[botInventoryLevel].inventory.grenades;

    if (randomByPercent(nadeNode.grenades_Chance)) {
        let newNades = []; // Define array to which new grenade objects will be added
        let placeInBotInventory = []; // Define array that will contain item objects that need to be parented to containers in the bot's inventory
        const randNumberOfNades = getRandomInt(nadeNode.grenades_Min, nadeNode.grenades_Max);

        if (randNumberOfNades > 0) {
            let nadeArray;

            if (nadeNode.forceItems.length > 0) { // This bot has forced nades
                nadeArray = nadeNode.forceItems;
            } else {
                nadeArray = [...Object.keys(dbNode.itemArray.grenades)];

                if (nadeNode.forbidItems.length > 0) { // This bot has forced nades
                    for (let i = nadeArray.length - 1; i >= 0; i--) { // Iterate backwards since we're removing items
                        if (nadeNode.forbidItems.includes(nadeArray[i])) {
                            nadeArray.splice(i, 1); // Remove forbidden nade
                        }
                    }
                }
            }

            if (nadeArray.length > 0) {
                if (nadeNode.matchGrenades) { // All grenades should match
                    const randNade = questHelperGetRandomItem(questHelperObj, nadeArray); // Use quest helper if enabled, otherwise random

                    for (let i = 0; i < randNumberOfNades; i++) {
                        let thisNewNade = utility.wipeDepend(newItem(randNade));

                        newNades.push(thisNewNade);
                        placeInBotInventory.push(thisNewNade);
                    }
                    debugOut(functionDebug, `${botRole}.${botInventoryLevel} -> Added ${randNumberOfNades} grenade: ${itemName(randNade)}`, 2);
                } else {
                    for (let i = 0; i < randNumberOfNades; i++) {
                        const randNade = questHelperGetRandomItem(questHelperObj, nadeArray); // Use quest helper if enabled, otherwise random
                        let thisNewNade = utility.wipeDepend(newItem(randNade));

                        newNades.push(thisNewNade);
                        placeInBotInventory.push(thisNewNade);
                        debugOut(functionDebug, `${botRole}.${botInventoryLevel} -> Added random grenade: ${itemName(randNade)}`, 2);
                    }
                }
            } else {
                debugOut(functionDebug, `${botRole}.${botInventoryLevel} -> All grenades have been excluded from this bot's inventory`, 1, 'warning');
                return;
            }

            if (newNades.length > 0) { // If new items were created
                for (const thisItem of newNades) {
                    newItemProperties(thisItem, dbgBotSettings[botInventoryLevel], botRole); // Send it off to get FIR status
                }

                if (placeInBotInventory.length > 0) {
                    const itemDiscardArray = addItemsToContainers(botInventory, placeInBotInventory, ['TacticalVest', 'Pockets', 'Backpack'], true); // Parent items to containers in the bot's inventory and give them location info
                    if (itemDiscardArray.length > 0) {
                        for (let i = newNades.length - 1; i >= 0; i--) { // Iterate backwards to remove elements
                            if (itemDiscardArray.includes(newNades[i]._id)) {
                                debugOut(functionDebug, `Removed unplaceable item ${newNades[i]._id} -> ${newNades[i]._tpl}`, 2);
                                newNades.splice(i, 1); // Remove it from the array
                            }
                        }
                    }
                }

                //console.info(newNades);
                botInventory.items.push(...newNades); // Add the contents of newNades to the bot's inventory
            }
        }
    } else {
        debugOut(functionDebug, `${botRole}.${botInventoryLevel} Bot failed roll for grenades`, 2);
    }
}

function newHealingItems(botInventory, botRole, dbgBotSettings, botInventoryLevel, questHelperObj) { // HealingItems adds loose loot to a bot's inventory based on settings
    const functionDebug = { name: 'dynamicBots.newHealingItems', debugMode: 0 }; // Debug settings for this function

    const healingNode = dbgBotSettings[botInventoryLevel].inventory.healing;

    let medItems = {
        injuryTreatment: [],
        medkits: [],
        painkillers: [],
        stims: [],
    }

    if (healingNode.forceItems.length > 0) { // If any healing items are forced
        for (const thisItem of healingNode.forceItems) {
            if (dbNode.itemArray.injuryTreatment.includes(thisItem)) {
                injuryTreatment.push(thisItem);
            } else if (dbNode.itemArray.medkits.includes(thisItem)) {
                medkits.push(thisItem);
            } else if (dbNode.itemArray.painkillers.includes(thisItem)) {
                painkillers.push(thisItem);
            } else if (dbNode.itemArray.stims.includes(thisItem)) {
                stims.push(thisItem);
            } else {
                debugOut(functionDebug, `${botRole}.${botInventoryLevel}.unknown item in inventory.healing.forceItems -> ${itemName(thisItem)}`, 0, 'error');
            }
        }
    }

    let newMeds = []; // Define array to which new medical objects will be added
    let placeInBotInventory = []; // Define array that will contain item objects that need to be parented to containers in the bot's inventory

    for (const thisMedType in medItems) {
        if (medItems[thisMedType].length == 0) { // If no forced items are in the ininjuryTreatment array, then populate it
            for (const thisItem in dbNode.itemArray[thisMedType]) {
                if (!healingNode.forbidItems.includes(thisItem) && dbNode.itemArray[thisMedType][thisItem] <= healingNode[`${thisMedType}_ValueMax`]) { // If this item isn't forbidden and its value is under the value threshold
                    medItems[thisMedType].push(thisItem);
                }
            }
        }

        if (medItems[thisMedType].length > 0 && healingNode[`${thisMedType}_Max`] > 0) { // If this med type has items in the array
            let numberOfMeds = getRandomInt(healingNode[`${thisMedType}_Min`], healingNode[`${thisMedType}_Max`]); // Roll to determine number of meds to generate
            for (let i = 0; i < numberOfMeds; i++) {
                const randMed = questHelperGetRandomItem(questHelperObj, medItems[thisMedType]); // Use quest helper if enabled, otherwise random

                let thisNewMed = utility.wipeDepend(newItem(randMed)); // Create the item

                newMeds.push(thisNewMed);
                placeInBotInventory.push(thisNewMed);
                debugOut(functionDebug, `${botRole}.${botInventoryLevel} -> Added random med: ${thisMedType} -> ${itemName(randMed)}`, 2);
            }
        } else {
            debugOut(functionDebug, `${botRole}.${botInventoryLevel} no ${thisMedType} items allowed by settings`, 2, 'error');
        }
    }

    if (newMeds.length > 0) { // If new items were created
        for (const thisItem of newMeds) {
            newItemProperties(thisItem, dbgBotSettings[botInventoryLevel], botRole); // Send it off to get FIR status
        }

        if (placeInBotInventory.length > 0) {
            const itemDiscardArray = addItemsToContainers(botInventory, placeInBotInventory, ['Pockets', 'TacticalVest', 'Backpack'], true); // Parent items to containers in the bot's inventory and give them location info
            if (itemDiscardArray.length > 0) {
                for (let i = newMeds.length - 1; i >= 0; i--) { // Iterate backwards to remove elements
                    if (itemDiscardArray.includes(newMeds[i]._id)) {
                        debugOut(functionDebug, `Removed unplaceable item ${newMeds[i]._id} -> ${newMeds[i]._tpl}`, 2);
                        newMeds.splice(i, 1); // Remove it from the array
                    }
                }
            }
        }

        //console.info(newMeds);
        botInventory.items.push(...newMeds); // Add the contents of newMeds to the bot's inventory
    }
}

function newRandomLoot(botInventory, botRole, dbgBotSettings, botInventoryLevel, questHelperObj) { // newRandomLoot adds loose loot to a bot's inventory based on settings and rarity (and specific loot if defined)
    const functionDebug = { name: 'dynamicBots.newRandomLoot', debugMode: 0 }; // Debug settings for this function

    const consumablesNode = dbgBotSettings[botInventoryLevel].inventory.consumables;
    const randomLootNode = dbgBotSettings[botInventoryLevel].inventory.randomLoot;

    const specificLootArray = dbgBotSettings[botInventoryLevel].inventory.specificLoot;
    let newLoot = []; // Define array to which new loot items will be added
    let placeInBotInventory = []; // Define array that will contain item objects that need to be parented to containers in the bot's inventory

    if (Object.keys(specificLootArray).length > 0) {
        for (const thisLoot in specificLootArray) {
            if (randomByPercent(specificLootArray[thisLoot])) { // Roll to see whether this bot receives this special loot
                let thisNewLoot = utility.wipeDepend(newItem(thisLoot)); // Create the item

                newLoot.push(thisNewLoot);
                placeInBotInventory.push(thisNewLoot);

                debugOut(functionDebug, `${botRole}.${botInventoryLevel} -> Added special loot: ${itemName(thisLoot)}`, 2);
            } else {
                debugOut(functionDebug, `${botRole}.${botInventoryLevel} -> Bot failed roll for special loot: ${itemName(thisLoot)}`, 3);
            }
        }
    } else {
        debugOut(functionDebug, `${botRole}.${botInventoryLevel} -> specificLootArray empty`, 3);
    }

    if (randomByPercent(randomLootNode.money_Chance) && randomLootNode.money_Max > 0) {
        const randMoney = getRandomInt(randomLootNode.money_Min, randomLootNode.money_Max); // Random amount of money (in roubles)

        let thisNewMoney = utility.wipeDepend(newItem(randomLootNode.money_Type)); // Create the item

        if (randomLootNode.money_Type == '5449016a4bdc2d6f028b456f') { // If money is already in roubles
            thisNewMoney.upd = { 'StackObjectsCount': randMoney }; // Set size of stack
        } else {
            const moneyConversion = Math.round(randMoney / dbNode.itemArray.money[randomLootNode.money_Type]); // Convert money from rouble value into this currency value
            thisNewMoney.upd = { 'StackObjectsCount': moneyConversion }; // Set size of stack
        }

        newLoot.push(thisNewMoney);
        placeInBotInventory.push(thisNewMoney);

        debugOut(functionDebug, `${botRole}.${botInventoryLevel} -> Added cash: ${itemName(randomLootNode.money_Type)} x${randMoney}`, 2);
    } else {
        debugOut(functionDebug, `${botRole}.${botInventoryLevel} -> Bot failed roll for money`, 3);
    }

    for (const thisConsumableType of ['drink', 'food']) {
        if (randomByPercent(consumablesNode[`${thisConsumableType}_Chance`]) && consumablesNode[`${thisConsumableType}_Max`] > 0) {
            const randNumberOfConsumables = getRandomInt(consumablesNode[`${thisConsumableType}_Min`], consumablesNode[`${thisConsumableType}_Max`]); // Roll to see how many consumable items this bot gets
            debugOut(functionDebug, `${botRole}.${botInventoryLevel} Bot will receive ${randNumberOfConsumables} random ${thisConsumableType} items`, 3);

            if (randNumberOfConsumables > 0) {
                let consumableArray = [];

                for (const thisConsumable in dbNode.itemArray[thisConsumableType]) {
                    if (dbNode.itemArray[thisConsumableType][thisConsumable] <= consumablesNode[`${thisConsumableType}_ValueMax`]) {
                        consumableArray.push(thisConsumable);
                    }
                }

                if (consumableArray.length > 0) {
                    for (let thisConsumablePlacement = 0; thisConsumablePlacement < randNumberOfConsumables; thisConsumablePlacement++) {
                        const randConsumable = questHelperGetRandomItem(questHelperObj, consumableArray); // Use quest helper if enabled, otherwise random

                        let thisNewConsumable = utility.wipeDepend(newItem(randConsumable)); // Create the item

                        newLoot.push(thisNewConsumable);
                        placeInBotInventory.push(thisNewConsumable);

                        debugOut(functionDebug, `${botRole}.${botInventoryLevel} -> Added consumable: ${itemName(randConsumable)}`, 3);
                    }
                } else {
                    debugOut(functionDebug, `${botRole}.${botInventoryLevel} no ${thisConsumableType} items allowed by settings`, 2, 'error');
                }
            }

        } else {
            debugOut(functionDebug, `${botRole}.${botInventoryLevel} -> Bot failed roll for ${thisConsumableType}`, 3);
        }
    }

    const randNumberOfLoot = getRandomInt(randomLootNode.items_Min, randomLootNode.items_Max); // Roll to see how many loot items this bot gets
    debugOut(functionDebug, `${botRole}.${botInventoryLevel} Bot will receive ${randNumberOfLoot} random loot items`, 2);

    const questHelperArray = Object.keys(questHelperObj); // Create array of quest helper item IDs
    let placedQuestHelperItem = false; // Will be set to true when an item is placed so one bot doesn't get all of the questHelper items

    for (let thisLootPlacement = 0; thisLootPlacement < randNumberOfLoot; thisLootPlacement++) {
        let randLoot;
        for (let lootAttempt = 0; lootAttempt < 10; lootAttempt++) { // Try 10 times to pick a random item from the loot pool that isn't forbidden
            let thisLoot;
            if (randomLootNode.forceItems.length > thisLootPlacement) {
                thisLoot = randomLootNode.forceItems[lootAttempt]; // Item from forced items pool
                debugOut(functionDebug, `${botRole}.${botInventoryLevel} -> Selected item from forced loot pool: ${itemName(thisLoot)}`, 2);
            } else {
                if (randomByPercent(randomLootNode.chanceForSuperRare)) { // Roll to see if bot will get a super rare item
                    if (placedQuestHelperItem) { // If a quest helper item has already been placed
                        thisLoot = getRandomFromArray(dbNode.itemArray.lootPool.superRare);
                    } else {
                        thisLoot = questHelperGetRandomItem(questHelperObj, dbNode.itemArray.lootPool.superRare); // Use quest helper if enabled, otherwise random
                    }
                    debugOut(functionDebug, `${botRole}.${botInventoryLevel} -> Selected item from \x1b[95msuper rare\x1b[0m loot pool: ${itemName(thisLoot)}`, 2);
                } else if (randomByPercent(randomLootNode.chanceForRare)) { // Roll to see if bot will get a rare item
                    if (placedQuestHelperItem) { // If a quest helper item has already been placed
                        thisLoot = getRandomFromArray(dbNode.itemArray.lootPool.rare);
                    } else {
                        thisLoot = questHelperGetRandomItem(questHelperObj, dbNode.itemArray.lootPool.rare); // Use quest helper if enabled, otherwise random
                    }
                    debugOut(functionDebug, `${botRole}.${botInventoryLevel} -> Selected item from \x1b[34mrare\x1b[0m loot pool: ${itemName(thisLoot)}`, 2);
                } else { // Bot gets a common item
                    if (placedQuestHelperItem) { // If a quest helper item has already been placed
                        thisLoot = getRandomFromArray(dbNode.itemArray.lootPool.common);
                    } else {
                        thisLoot = questHelperGetRandomItem(questHelperObj, dbNode.itemArray.lootPool.common); // Use quest helper if enabled, otherwise random
                    }
                    debugOut(functionDebug, `${botRole}.${botInventoryLevel} -> Selected item from common loot pool: ${itemName(thisLoot)}`, 2);
                }
            }

            if (randomLootNode.forbidItems.includes(thisLoot)) { // If the random item chosen is forbidden
                debugOut(functionDebug, `${botRole}.${botInventoryLevel} -> Selected loot item is forbidden, rolling again`, 2, 'warning');
                continue; // Roll again
            } else {
                randLoot = thisLoot;
                break;
            }
        }

        if (randLoot == null) {
            debugOut(functionDebug, `${botRole}.${botInventoryLevel} -> Unable to select a random loot item from the pool`, 2, 'warning');
        } else {
            if (questHelperArray.includes(randLoot)) {
                placedQuestHelperItem = true; // Flag as true so this bot doesn't get any more quest helper inventory loot
            }

            let thisNewLoot = utility.wipeDepend(newItem(randLoot)); // Create the item

            if (isDefined(dbNode.itemArray.ammo, randLoot)) { // If this is loose ammo
                if (isDefined(itemDB, `${randLoot}._props.StackMaxSize`)) {
                    const maxStack = itemDB[randLoot]._props.StackMaxSize;

                    thisNewLoot.upd = {
                        'StackObjectsCount': getRandomInt(maxStack * .25, maxStack) // Anywhere from 25% of a stack to a full stack of ammo
                    };
                }
            }

            newLoot.push(thisNewLoot);
            placeInBotInventory.push(thisNewLoot);

            if (isDefined(dbNode.itemArray.ammoBoxes, randLoot)) { // If this is a box of ammo
                if (isDefined(itemDB, `${randLoot}._props.StackSlots`)) {
                    const slotNode = itemDB[randLoot]._props.StackSlots[0];
                    if (isDefined(slotNode, '_props.filters')) {
                        const cartridgesTPL = slotNode._props.filters[0].Filter[0];

                        let cartridgesItem = utility.wipeDepend(newItem(cartridgesTPL, thisNewLoot._id, 'cartridges')); // Create the cartridges that go in the box

                        cartridgesItem.upd = {
                            'StackObjectsCount': slotNode._max_count // Set the ammo stack size to the box capacity count
                        };

                        newLoot.push(cartridgesItem); // Cartridges are parented to the box rather than the inventory so they don't need to be placed in container
                    }
                }
            }
            //console.info(newLoot);
        }
    }

    if (newLoot.length > 0) { // If new items were created
        for (const thisItem of newLoot) {
            newItemProperties(thisItem, dbgBotSettings[botInventoryLevel], botRole); // Send it off to get FIR status
        }

        if (placeInBotInventory.length > 0) {
            const itemDiscardArray = addItemsToContainers(botInventory, placeInBotInventory, ['Backpack', 'Pockets', 'TacticalVest'], true); // Parent items to containers in the bot's inventory and give them location info
            if (itemDiscardArray.length > 0) {
                for (let i = newLoot.length - 1; i >= 0; i--) { // Iterate backwards to remove elements
                    if (itemDiscardArray.includes(newLoot[i]._id)) {
                        debugOut(functionDebug, `Removed unplaceable item ${newLoot[i]._id} -> ${newLoot[i]._tpl}`, 2);
                        newLoot.splice(i, 1); // Remove it from the array
                    }
                }
            }
        }

        //console.info(newLoot);
        botInventory.items.push(...newLoot); // Add the contents of newLoot to the bot's inventory
    }
}

function questHelperReadPMC(pmcData, isPlayerBot) { // questHelperReadPMC reads quests from pmcData and generates a questHelperObj to be used during bot generation
    const functionDebug = { name: 'dynamicBots.questHelperReadPMC', debugMode: 0 }; // Debug settings for this function

    if (!isPlayerBot && isDefined(dbSettingsNode, 'questHelperEnabled') && dbSettingsNode.questHelperEnabled) { // If this isn't a player scav and quest helper is enabled
        if (isDefined(dbNode, `questHelper.${pmcData.aid}.generationTime`) && (Date.now() - dbNode.questHelper[pmcData.aid].generationTime) < 30000) { // If data already exists for this AID and it's less than 30 seconds old
            debugOut(functionDebug, 'questHelper array is still fresh; returning cached array', 3);
            return dbNode.questHelper[pmcData.aid].items;
        } else { // If the quest helper object doesn't exist yet or is too old
            let questHelperItemsObj = {};

            for (const thisQuestObj of pmcData.Quests) { // Iterate player's quests to find active quests that require found items
                if (isDefined(thisQuestObj, 'status') && thisQuestObj.status == 'Started' && isDefined(thisQuestObj, 'qid') && isDefined(thisQuestObj, 'completedConditions')) { // If the player is currently on this quest
                    if (isDefined(dbNode.questObjectives, thisQuestObj.qid)) { // If this is a quest with item objectives
                        for (const thisQuestCondition in dbNode.questObjectives[thisQuestObj.qid]) {
                            let thisQuestRef = { // Create an object that each thisQuestTarget item will reference, so they all share the same quantity when items are spawned
                                quantityToSpawn: dbNode.questObjectives[thisQuestObj.qid][thisQuestCondition].quantity, // Total quantity needed to complete this quest
                                extractedItems: [], // IDs of items successfully extracted in offraid
                                spawnedItems: []    // IDs of items spawned between extracts (this is reset in offraid)
                            };

                            for (const thisQuestTarget of dbNode.questObjectives[thisQuestObj.qid][thisQuestCondition].items) { // Iterate through items targeted by this quest (items needed for turn-in)
                                questHelperItemsObj[thisQuestTarget] = thisQuestRef;

                                for (const thisArrayType of ['extractedItems', 'spawnedItems']) {
                                    if (isDefined(dbNode.questHelper, `${pmcData.aid}.items.${thisQuestTarget}.${thisArrayType}`)) { // If there's an existing quest object in the db
                                        for (const thisSpawnedItem of dbNode.questHelper[pmcData.aid].items[thisQuestTarget][thisArrayType]) {
                                            if (!thisQuestRef[thisArrayType].includes(thisSpawnedItem)) { // If this item and it isn't already in thisQuestRef.extractedItems/spawnedItems
                                                thisQuestRef[thisArrayType].push(thisSpawnedItem);
                                            }
                                        }
                                    }
                                }

                            }
                        }
                    }
                }
            }

            dbNode.questHelper[pmcData.aid] = { // Set the DB obj for this AID
                generationTime: Date.now(),
                items: questHelperItemsObj
            };

            fs.mkdirSync(aeNode.constants.modDir + '/data', { recursive: true });
            fs.writeFileSync(aeNode.constants.modDir + '/data/questHelper.json', JSON.stringify(dbNode.questHelper, null, '\t'), 'utf8'); // Save to file so progress can be maintained between sessions

            return questHelperItemsObj;
        }
    } else { // Quest helper disabled
        return {};
    }
}

function questHelperGetRandomItem(questHelperObj, itemArray, isPreset = false) { // questHelperGetRandomItem checks the itemArray of allowed items against the questHelperObj which contains items that the PMC needs for quests and gives a quest item if possible
    const functionDebug = { name: 'dynamicBots.getRandomQuestHelperItem', debugMode: 0 }; // Debug settings for this function

    const questHelperArray = Object.keys(questHelperObj); // Create array of quest helper item IDs

    if (questHelperArray.length == 0) { // Either quest helper is disabled or player has no active quests
        debugOut(functionDebug, 'Quest helper disabled. Returning random from itemArray', 3);
        return getRandomFromArray(itemArray);
    } else {
        if (isPreset) {
            let baseMatches = [];
            let presetMatches = [];

            for (const thisPreset of itemArray) {
                const thisBaseID = globalsDB.ItemPresets[thisPreset]._items[0]._tpl;

                if (questHelperArray.includes(thisBaseID)) {
                    baseMatches.push(thisBaseID);
                    presetMatches.push(thisPreset);
                }
            }

            for (let thisMatchAttempt = baseMatches.length; thisMatchAttempt > 0; thisMatchAttempt--) { // Try to match from baseMatches
                const randQuestMatchIndex = getRandomInt(0, baseMatches.length - 1); // Pick a random index
                const randQuestMatch = baseMatches[randQuestMatchIndex];
                const alreadySpawned = questHelperObj[randQuestMatch].extractedItems.length + questHelperObj[randQuestMatch].spawnedItems.length;

                if (questHelperObj[randQuestMatch].quantityToSpawn > alreadySpawned) { // If this match still has quantity left to spawn
                    if (isDefined(localeDB.preset, `${presetMatches[randQuestMatchIndex]}.Name`) && localeDB.preset[presetMatches[randQuestMatchIndex]].Name != null) {
                        debugOut(functionDebug, `${questHelperObj[randQuestMatch].quantityToSpawn} > ${alreadySpawned} -> Returning random quest preset: ${localeDB.templates[randQuestMatch].Name} -> ${localeDB.preset[presetMatches[randQuestMatchIndex]].Name} (${presetMatches[randQuestMatchIndex]})`, 2);
                    } else {
                        debugOut(functionDebug, `${questHelperObj[randQuestMatch].quantityToSpawn} > ${alreadySpawned} -> Returning random quest preset: ${localeDB.templates[randQuestMatch].Name} -> ${presetMatches[randQuestMatchIndex]}`, 2);
                    }
                    return presetMatches[randQuestMatchIndex];
                } else {
                    baseMatches.splice(randQuestMatchIndex, 1); // If this item has had its full quantity spawned, then remove it from matches
                    presetMatches.splice(randQuestMatchIndex, 1);
                }
            }
        } else {
            const questMatches = itemArray.filter(thisItem => questHelperArray.includes(thisItem));

            for (let thisMatchAttempt = questMatches.length; thisMatchAttempt > 0; thisMatchAttempt--) { // Try to match from questMatches
                const randQuestMatchIndex = getRandomInt(0, questMatches.length - 1); // Pick a random index
                const randQuestMatch = questMatches[randQuestMatchIndex];
                const alreadySpawned = questHelperObj[randQuestMatch].extractedItems.length + questHelperObj[randQuestMatch].spawnedItems.length;

                if (questHelperObj[randQuestMatch].quantityToSpawn > alreadySpawned) { // If this match still has quantity left to spawn
                    debugOut(functionDebug, `${questHelperObj[randQuestMatch].quantityToSpawn} > ${alreadySpawned} -> Returning random quest item: ${localeDB.templates[randQuestMatch].Name}`, 2);
                    return randQuestMatch;
                } else {
                    questMatches.splice(randQuestMatchIndex, 1); // If this item has had its full quantity spawned, then remove it from matches
                }
            }
        }

        // If we completed the for loop without returning a match, then no matched items still have quantity left to spawn; therefore return a random item from itemArray
        debugOut(functionDebug, 'Returning random from itemArray', 3);
        return getRandomFromArray(itemArray);
    }
}